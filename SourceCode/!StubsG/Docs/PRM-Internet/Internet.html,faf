<html>
<head>
<title>RISC OS PRMs: Volume 5a: Chapter 123: The Internet module</title>
</head>
<body bgcolor="white" text="black" link="blue" alink="red" vlink="darkblue">
<hr>

<h1><a name="10701"></a><a name="marker-329894"></a>The Internet module</h1>
<hr>
<dl>

<dt>
<h2><a name="idx-5346"></a>Introduction</h2>
<dd>
<dl>
<dd>
<p>This chapter gives you the guidance and reference material you need to use the socket level programming interfaces provided by the Internet module. We strongly recommend that you only do so once you have a good understanding of Internet protocols and the use of sockets. You should also note that our support services would prefer not to support the Internet module at a tutorial level, since this does not make the most effective use of their resources.</p>
</dl>

<dt>
<h4><a name="idx-5347"></a>The Internet module</h4>
<dd>
<dl>
<dd>
<p>The Internet module has been derived from the Berkeley networking software that was incorporated into the 4.3 BSD 'Reno' release of UNIX (also known as 'net-1'), and into subsequent variations - including Acorn RISC iX. Consequently, the concepts and (to a large extent) the specifics of the programming interface to the Internet module are identical to those provided under BSD UNIX. Most of the differences between the two are caused by differences between the programming environments provided by RISC OS and by UNIX: for example the mechanisms for asynchronous event notification, the assumptions about task scheduling conventions, and so on.</p>
<p>The version of the <a name="marker-326570"></a>Internet module in the RISC OS 3.5 ROM is only a partial implementation of the Internet stack, supporting only those <a name="marker-326578"></a><a name="marker-326579"></a>protocols needed by then-existent Acorn products. It uses version 2 of the DCI (<i>Driver Control Interface</i><a name="marker-326580"></a>). The Internet module in the RISC OS 3.6 ROM (and later) uses DCI 4, and provides a full implementation of the protocol stack. If you wish to program using the Internet socket interface, you should use the full version of the module; see <A HREF="#55920">Getting the libraries and full Internet module</a>.</p>
</dl>

<dt>
<h4><a name="idx-5348"></a>The Internet C libraries</h4>
<dd>
<dl>
<dd>
<p><a name="marker-326593"></a><a name="marker-326587"></a><a name="marker-326581"></a>Acorn has C <a name="marker-326639"></a>libraries available to help you program the Internet module, which provide the same calls as are used in BSD Unix networking software. Although the Internet module provides a SWI interface, we strongly recommend that you use the libraries, as they provide many extra facilities. They will make it easier to program, especially when porting software; and will enable you to get help from a wealth of supporting books and materials.</p>
</dl>

<dt>
<h4><a name="55920"></a>Getting the libraries and full Internet module</h4>
<dd>
<dl>
<dd>
<p>The libraries - Inetlib, Socklib and Unixlib - are available from Acorn's FTP site (ftp.acorn.co.uk), or on request from Acorn. There are two versions of each library:</p>
<ul>
<li>The filenames ending in <tt>zm</tt> are versions intended for use with modules. They are compiled using the zps1, ff and zM switches in the C compiler, so there is no stack limit checking, function names are not embedded, and they are suitable for linking into relocatable modules.
<li>The other versions are versions intended for use with standard applications. They are compiled using the zps0 and fn switches in the C compiler (but not the zM switch), so there is stack limit checking, function names are embedded, and they are not suitable for linking into relocatable modules.
</ul>
<p>The <a name="marker-326611"></a>Internet application is also available from Acorn's FTP site. This includes the current version of the Internet module, which provides a full implementation of the socket interface.</p>
</dl>

<dt>
<h4><a name="idx-5349"></a>Contents of this chapter</h4>
<dd>
<dl>
<dd>
<p>This chapter describes the library calls we recommend you use, rather than describing the more limited range of SWIs. Its organisation is therefore a little different from other chapters in this manual:</p>
<ul>
<li><A HREF="#69869">Introductory tutorial</a> gives an introductory tutorial to programming with the Internet module using the libraries.
<li><A HREF="#67890">Advanced tutorial</a> contains a more advanced tutorial.
<li><A HREF="MODULES.HTML#51065">Protocols</a> describes the protocols used by the Internet module.
<li><A HREF="VDU.HTML#90856">Library calls</a> details the calls in the Socklib library, the Inetlib library, and the Unixlib library. The section starts with an index of the calls.<a name="marker-326583"></a><a name="marker-326589"></a><a name="marker-326595"></a>
<li><A HREF="#88077">Service calls</a> describes the service calls used by the Internet module and network device drivers.
<li><A HREF="#15833">SWI calls</a> describes how to call the Internet module's Socket_... SWI calls; it refers to the earlier documentation.
<li><A HREF="#37770">* Commands</a> describes the * commands provided by the Internet module.
</ul>

<dt>
<h5><a name="idx-5350"></a>About the tutorial sections</h5>
<dd>
<p>The <a name="marker-326612"></a>tutorial sections are derived from sections 7 and 8 of the 4.3 BSD <i>Unix Programmer's Manual Supplementary Documents 1</i> (or <i>PS1</i>). By comparing the two, experienced Internet programmers will be able to see the changes that have been necessary to port the software to RISC OS.</p>
<p>You should also note that the examples in the tutorials assume a pre-emptive <a name="marker-326622"></a>multitasking environment such as UNIX, where even if a call does not return for an indefinite period, other programs continue to run. This is not the case for RISC OS. <b>The example programs do not necessarily multitask correctly under RISC OS.</b> Before adapting any of the example code for use in RISC OS, you should be aware of which calls might not return promptly, and why; and you should read <A HREF="#63340">Multitasking</a> to find out how to avoid any problems with such calls.</p>

<dt>
<h5><a name="idx-5351"></a>About the protocol and library call sections</h5>
<dd>
<p>We've deliberately kept the documentation of <a name="marker-326638"></a>protocols and <a name="marker-326635"></a><a name="marker-326636"></a><a name="marker-326637"></a>library calls as similar as possible to normal 4.3 BSD UNIX documentation, so you can easily see what changes we've had to make to cater for RISC OS. (You'll find the equivalent BSD manual pages in sections 2, 3 and 4 of a 4.3 BSD UNIX online manual.) Note that some section headings have been changed for consistency. The function prototypes have also been made consistent in style. Each prototype includes those header files needed to call the functions; the functions' <i>Description</i> may mention other useful header files, such as constants that may be passed to/from functions.</p>
</dl>

<dt>
<h4><a name="idx-5352"></a>Finding out more...</h4>
<dd>
<dl>
<dd>
<p><a name="marker-326613"></a>As well as the tutorials in this chapter, you may also find the following book helpful:</p>
<ul>
<li>UNIX Network Programming / W. Richard Stevens. - Englewood Cliffs, NJ, USA: Prentice Hall, 1990.
</ul>
</dl>

<dt>
<h2><a name="69869"></a>Introductory <a name="marker-326615"></a>tutorial</h2>

<dt>
<h4><a name="idx-5353"></a>Introduction</h4>
<dd>
<dl>
<dd>
<p>RISC OS offers several choices for interprocess communication. To aid the programmer in developing applications which are comprised of cooperating programs, the different choices are discussed and a series of example programs are presented. These programs demonstrate in a simple way the use of sockets and the use of datagram and stream communication. The intent of this tutorial is to present a few simple example programs, not to describe the networking system in full.</p>
</dl>

<dt>
<h4><a name="idx-5354"></a>Overview</h4>
<dd>
<dl>
<dd>
<p>At the core of interprocess communication are <i>sockets</i><a name="marker-327492"></a>, from which one reads, and to which one writes. The use of a socket has three phases: its <a name="marker-328455"></a>creation, its use for <a name="marker-328456"></a>reading and <a name="marker-328457"></a>writing, and its <a name="marker-328458"></a>destruction. One can write to a socket without full assurance of delivery, since one can check later to catch occasional failures. Messages between sockets can be kept as <a name="marker-328459"></a>discrete units, or merged into a <a name="marker-328460"></a>stream. One can ask to read, but insist on <a name="marker-328461"></a>not waiting if nothing is immediately available.</p>
<p>This tutorial presents simple examples that illustrate some of the ways of doing interprocess communication in RISC OS. We presume you are familiar with the C programming language, but not necessarily with system calls or with interprocess communication. The tutorial reviews the types of communication that are supported by RISC OS. A series of examples are presented that illustrate programs communicating with each other; they show different ways of establishing channels of communication. Finally, the calls that actually transfer data are reviewed. To clearly present how communication can take place, the example programs have been cleared of anything that might be construed as useful work.</p>
</dl>

<dt>
<h4><a name="idx-5355"></a>Domains and protocols</h4>
<dd>
<dl>
<dd>
<p>If we want to communicate between two independent programs, we would like to have them separately <a name="marker-328462"></a>create sockets, and then have messages sent between the sockets. This is often the case when providing or using a service in the system. This is also the case when the communicating programs are on separate machines. In RISC OS one can create individual sockets, give them <a name="marker-328463"></a>names and send messages between them.</p>
<p>Sockets created by different programs use names to refer to one another; names generally must be translated into addresses for use. The space from which an address is drawn is referred to as a <a name="marker-327493"></a>domain. RISC OS supports a single domain for sockets, that will be used in the examples here. This is the Internet domain (or <a name="marker-327533"></a>AF_INET, for Address Format InterNET). The Internet domain is an implementation of the DARPA Internet standard protocols IP/TCP/UDP.<a name="marker-327495"></a> <a name="marker-327534"></a>Addresses in the Internet domain consist of a machine network address and an identifying number, called a <a name="marker-327535"></a>port. Internet domain names allow communication between machines.<a name="marker-328442"></a></p>
<p>Communication follows some particular <a name="marker-327553"></a>'style.' Currently, communication is either through a <a name="marker-327536"></a>stream or by <a name="marker-327537"></a>datagram. Stream communication implies several things. Communication takes place across a connection between two sockets. The communication is reliable, error-free, and no message boundaries are kept. <a name="marker-327540"></a>Reading from a stream may result in reading the data sent from one or several calls to socketwrite() or only part of the data from a single call, if there is not enough room for the entire message, or if not all the data from a large message has been transferred. The <a name="marker-327550"></a>protocol implementing such a style will retransmit messages received with errors. It will also return <a name="marker-327551"></a>error messages if one tries to <a name="marker-327546"></a>send a message after the connection has been broken. Datagram communication does not use connections. Each message is addressed individually. If the address is correct, it will generally be received, although this is not guaranteed. Often datagrams are used for requests that require a response from the recipient. If no response arrives in a reasonable amount of time, the request is repeated. The individual datagrams will be kept separate when they are read, that is, message boundaries are preserved.</p>
<p>The difference in performance between the two styles of communication is generally less important than the difference in semantics. The performance gain that one might find in using datagrams must be weighed against the increased complexity of the program, which must now concern itself with lost or out of order messages. If lost messages may simply be ignored, the quantity of traffic may be a consideration. The expense of setting up a connection is best justified by frequent use of the connection. Since the performance of a protocol changes as it is tuned for different situations, it is best to seek the most up-to-date information when making choices for a program in which performance is crucial.</p>
<p>A <a name="marker-327552"></a>protocol is a set of rules, data formats and conventions that regulate the transfer of data between participants in the communication. In general, there is one protocol for each socket <a name="marker-327556"></a>type (stream, datagram, etc.) within each domain. The code that implements a protocol keeps track of the names that are bound to sockets, sets up connections and transfers data between sockets, perhaps sending the data across a network. This code also keeps track of the names that are bound to sockets. It is possible for several protocols, differing only in low level details, to implement the same style of communication within a particular domain. Although it is possible to select which protocol should be used, for nearly all uses it is sufficient to request the default protocol. This has been done in all of the example programs.</p>
<p>One specifies the domain, style and protocol of a <a name="marker-327560"></a>socket when it is created. For example, in <A HREF="#85583">Reading Internet domain datagrams</a> the call to socket() causes the creation of a datagram socket with the default protocol in the Internet domain.</p>
</dl>

<dt>
<h4><a name="idx-5356"></a>Closing sockets</h4>
<dd>
<dl>
<dd>
<p>It is particularly important that you ensure your applications close all <a name="marker-327561"></a>sockets before quitting, say in an <a name="marker-329963"></a>atexit() routine. This is only shown in the first example program (<A HREF="#85583">Reading Internet domain datagrams</a>); other examples omit this for reasons of space and clarity.</p>
<p>If an application terminates under RISC OS without closing an open socket, then that socket will remain open indefinitely. This needlessly consumes resources; and it leaves fewer sockets available for other programs to use, since <a name="marker-327562"></a>socket descriptors are kept in a single fixed-size table.</p>
</dl>

<dt>
<h4><a name="idx-5357"></a>Datagrams in the Internet domain</h4>
<dd>
<dl>
<dd>
<p>Let us now look at two programs that <a name="marker-327564"></a>create sockets separately. The programs in <A HREF="#85583">Reading Internet domain datagrams</a> and <A HREF="#31146">Sending an Internet domain datagram</a> use <a name="marker-327644"></a>datagram communication rather than a stream. The structure used to name Internet domain sockets is defined in the file "netinet/in.h". The definition has also been included in the example for clarity.</p>
<p><pre><a name="marker-327714"></a>#include &lt;stdio.h&gt;
#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"
/*
 * In the included file "netinet/in.h" a sockaddr_in is defined as follows:
 * struct sockaddr_in
 * {
 *   short   sin_family;
 *   u_short sin_port;
 *   struct  in_addr sin_addr;
 *   char    sin_zero[8];
 * };
 *
 * This program creates a datagram socket, binds a name to it, then reads
 * from the socket.
 */
char buf[1024]; /* global rather than auto, so doesn't go on SVC stack */
int  sock = -1; /* mark socket as initially closed */
finalise()      /* exit handler to close socket, registered with atexit */
{
  if (sock != -1)
  {                     /* if socket not already closed */
    socketclose(sock);  /* close it */
    sock = -1;          /* and mark it as closed */
  }
}
main()
{
  int                length;
  struct sockaddr_in name;
  /* Register finalisation code to close socket at exit */
  if (atexit(finalise) != 0)
  {
    fprintf(stderr, "Unable to register exit handler\n");
    exit(1);
  }
  /* Create socket from which to read. */
  sock = socket(AF_INET, SOCK_DGRAM, 0);
  if (sock &lt; 0)
  {
    xperror("opening datagram socket");
    exit(1);
  }
  /* Create name with wildcards. */
  name.sin_family = AF_INET;
  name.sin_addr.s_addr = INADDR_ANY;
  name.sin_port = 0;
  if (bind(sock, &amp;name, sizeof(name)))
  {
    xperror("binding datagram socket");
    exit(1);
  }
  /* Find assigned port value and print it out. */
  length = sizeof(name);
  if (getsockname(sock, &amp;name, &amp;length))
  {
    xperror("getting socket name");
    exit(1);
  }
  printf("Socket has port #%d\n", ntohs(name.sin_port));
  /* Read from the socket */
  if (socketread(sock, buf, 1024) &lt; 0)
    xperror("receiving datagram packet");
  printf("--&gt;%s\n", buf);
  /* Close the socket */
  socketclose(sock);
  sock = -1;  /* mark it as closed */
}</pre><a name="marker-327719"></a></p>
<p align="center">
<i><a name="85583"></a>Reading Internet domain datagrams</i></p>
<p>Each program creates a socket with a call to socket(). These sockets are in the Internet domain. Once a <a name="marker-327570"></a>name has been created it is attached to a socket by the system call bind(). The routine in <A HREF="#31146">Sending an Internet domain datagram</a> uses its socket only for sending messages. It does not create a name for the socket because no other program has to refer to it.</p>
<p><pre>#include &lt;stdio.h&gt;
#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"
#include "netdb.h"
#define DATA "The sea is calm tonight, the tide is full . . ."
/*
 * Here I send a datagram to a receiver whose name I get from the command
 * line arguments. The form of the command line is dgramsend hostname
 * portnumber
 */
main(argc, argv)
  int argc;
  char *argv[];
{
  int                 sock;
  struct sockaddr_in  name;
  struct hostent     *hp,
                     *gethostbyname();
  /* Create socket on which to send. */
  sock = socket(AF_INET, SOCK_DGRAM, 0);
  if (sock &lt; 0)
  {
    xperror("opening datagram socket");
    exit(1);
  }
  /*
   * Construct name, with no wildcards, of the socket to send to.
   * Gethostbyname() returns a structure including the network 
   * address of the specified host. The port number is taken from 
   * the command line.
   */
  hp = gethostbyname(argv[1]);
  if (hp == 0)
  {
    fprintf(stderr, "%s: unknown host\n", argv[1]);
    exit(2);
  }
  bcopy(hp-&gt;h_addr, &amp;name.sin_addr, hp-&gt;h_length);
  name.sin_family = AF_INET;
  name.sin_port = htons(atoi(argv[2]));
  /* Send message. */
  if (sendto(sock, DATA, sizeof(DATA), 0, &amp;name, sizeof(name)) &lt; 0)
    xperror("sending datagram message");
  socketclose(sock);
}</pre></p>
<p align="center">
<i><a name="31146"></a>Sending an Internet domain datagram</i></p>
<p><a name="marker-327576"></a>Internet addresses specify a host address (a 32-bit number) and a delivery slot, or <a name="marker-327577"></a>port, on that machine. These ports are managed by the system routines that implement a particular <a name="marker-327603"></a>protocol. When a message must be <a name="marker-327592"></a>sent between machines it is sent to the protocol routine on the destination machine, which interprets the address to determine to which socket the message should be delivered. Several different protocols may be active on the same machine, but, in general, they will not communicate with one another. As a result, different protocols are allowed to use the same port numbers. Thus, implicitly, an Internet address is a triple including a protocol as well as the port and machine address. An association is a temporary or permanent specification of a pair of communicating sockets. An association is thus identified by the tuple &lt;protocol, local machine address, local port, remote machine address, remote port&gt;. An association may be transient when using datagram sockets; the association actually exists during a send operation.</p>
<p>The protocol for a socket is chosen when the socket is created.<a name="marker-328287"></a> The local machine address for a socket can be any valid network address of the machine, if it has more than one, or it can be the <a name="marker-328289"></a>wildcard value <a name="marker-328290"></a>INADDR_ANY. The wildcard value is used in the program in <A HREF="#85583">Reading Internet domain datagrams</a>. If a machine has several network addresses, it is likely that messages sent to any of the addresses should be deliverable to a socket. This will be the case if the wildcard value has been chosen. Note that even if the wildcard value is chosen, a program sending messages to the named socket must specify a valid network address. One can be willing to receive from 'anywhere', but one cannot send a message 'anywhere'. The program in <A HREF="#31146">Sending an Internet domain datagram</a> is given the destination host name as a command line argument. To determine a network address to which it can send the message, it looks up the host address by the call to <a name="marker-328297"></a>gethostbyname(). The returned structure includes the host's network address, which is copied into the structure specifying the destination of the message.</p>
<p>The <a name="marker-327615"></a>port number can be thought of as the number of a mailbox, into which the protocol places one's messages. Certain daemons, offering certain advertised services, have reserved or 'well-known' port numbers. These fall in the range from 1 to 1023. Higher numbers are available to general users. Only servers need to ask for a particular number. The system will assign an unused port number when an address is bound to a socket. This may happen when an explicit bind call is made with a port number of 0, or when a connect or send is performed on an unbound socket. Note that port numbers are not automatically reported back to the user. After calling bind(), asking for port 0, one may call getsockname() to discover what port was actually assigned.<a name="marker-327572"></a></p>
<p>The format of the socket address is specified in part by standards within the Internet domain. The specification includes the order of the <a name="marker-327809"></a>bytes in the address. Because machines differ in the internal representation they ordinarily use to represent integers, printing out the port number as returned by getsockname() may result in a misinterpretation. To print out the number, it is necessary to use the routine ntohs() (for network to host: short) to convert the number from the network representation to the host's representation. On some machines, such as 68000-based machines, this is a null operation. On others, such as ARMs and VAXes, this results in a swapping of bytes. Another routine exists to convert a short integer from the host format to the network format, called htons(); similar routines exist for long integers.<a name="marker-327566"></a><a name="marker-327580"></a><a name="marker-327646"></a></p>
</dl>
<dt>
<a name="59490"></a><h4><a name="idx-5358"></a>Connections</h4>
<dd>
<dl>
<dd>
<p><a name="marker-327638"></a>To send data between <a name="marker-327650"></a>stream sockets (having communication style SOCK_STREAM), the sockets must be connected. <A HREF="#31630">Initiating an Internet domain stream connection</a> and <A HREF="#84601">Accepting an Internet domain stream connection</a> show two programs that create such a connection. The program in <A HREF="#31630">Initiating an Internet domain stream connection</a> is relatively simple. To <a name="marker-327656"></a>initiate a connection, this program simply creates a stream socket, then calls connect(), specifying the address of the socket to which it wishes its socket connected. Provided that the target socket exists and is prepared to handle a connection, connection will be complete, and the program can begin to send messages. Messages will be delivered in order without message boundaries. The <a name="marker-327684"></a>connection is destroyed when either <a name="marker-327683"></a>socket is closed (or soon thereafter). If a program tries to <a name="marker-327685"></a>send messages after the connection is closed, the call will fail, and the errno variable is set to '<a name="marker-327682"></a>EPIPE'.</p>
<p><pre>#include &lt;stdio.h&gt;
#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"
#include "netdb.h"
#define DATA "Half a league, half a league . . ."
/*
 * This program creates a socket and initiates a connection with the socket
 * given in the command line. One message is sent over the connection and
 * then the socket is closed, ending the connection. The form of the
 * command line is streamwrite hostname portnumber
 */
char buf[1024];         /* global rather than auto, so doesn't go on SVC stack */
main(argc, argv)
  int argc;
  char *argv[];
{
  int                 sock;
  struct sockaddr_in  server;
  struct hostent     *hp,
                     *gethostbyname();
  /* Create socket */
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock &lt; 0)
  {
    xperror("opening stream socket");
    exit(1);
  }
  /* Connect socket using name specified by command line. */
  server.sin_family = AF_INET;
  hp = gethostbyname(argv[1]);
  if (hp == 0)
  {
    fprintf(stderr, "%s: unknown host\n", argv[1]);
    exit(2);
  }
  bcopy(hp-&gt;h_addr, &amp;server.sin_addr, hp-&gt;h_length);
  server.sin_port = htons(atoi(argv[2]));
  if (connect(sock, &amp;server, sizeof(server)) &lt; 0)
  {
    xperror("connecting stream socket");
    exit(1);
  }
  if (socketwrite(sock, DATA, sizeof(DATA)) &lt; 0)
    xperror("writing on stream socket");
  close(sock);
}<a name="marker-327782"></a></pre></p>
<p align="center">
<i><a name="31630"></a>Initiating an Internet domain stream connection</i></p>
<p>Forming a connection is asymmetrical; one program, such as the program in <A HREF="#31630">Initiating an Internet domain stream connection</a>, requests a connection with a particular socket, the other program <a name="marker-327686"></a>accepts connection requests. Before a connection can be accepted a socket must be created and an address bound to it. This situation is illustrated in the top half of <A HREF="#15163">Establishing a stream connection</a>. Program 2 has created a socket and bound a port number to it. Program 1 has created an unnamed socket. The address bound to Program 2's socket is then made known to Program 1 and, perhaps to several other potential communicants as well. If there are several possible communicants, this one socket might receive several requests for connections. As a result, a new socket is created for each connection. This new socket is the endpoint for communication within this program for this connection. A connection may be <a name="marker-327689"></a>destroyed by closing the corresponding socket.</p>
<p align="center">
<a href="Internet-2.draw"><img src="Internet-2.png"  border=0></a></p>
<p align="center">
<i><a name="15163"></a>Establishing a stream connection</i></p>
<p>The program in <A HREF="#84601">Accepting an Internet domain stream connection</a> is a rather trivial example of a server. It creates a socket to which it binds a name, which it then advertises. (In this case it prints out the socket number.) The program then calls <a name="marker-327693"></a>listen() for this socket. Since several clients may attempt to connect more or less simultaneously, a queue of pending connections is maintained in the system address space. Listen() marks the socket as willing to accept connections and initializes the queue. When a connection is requested, it is listed in the queue. If the queue is full, an error status may be returned to the requester. The maximum length of this queue is specified by the second argument of listen(); the maximum length is limited by the system. Once the listen call has been completed, the program enters an infinite loop. On each pass through the loop, a new connection is accepted and removed from the queue, and, hence, a new socket for the connection is created.<a name="marker-327697"></a> The bottom half of <A HREF="#15163">Establishing a stream connection</a> shows the result of Program 1 connecting with the named socket of Program 2, and Program 2 accepting the connection. After the connection is created, the service, in this case printing out the messages, is performed and the connection socket closed. The accept() call will take a pending connection request from the queue if one is available, or block waiting for a request. Messages are read from the connection socket. Reads from an active connection will normally block until data is available. The number of bytes read is returned. When a connection is destroyed, the read call returns immediately. The number of bytes returned will be zero.<a name="marker-327764"></a></p>
<p><a name="marker-327706"></a><pre>#include &lt;stdio.h&gt;
#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"
#include "netdb.h"
#define TRUE 1
/*
 * This program creates a socket and then begins an infinite loop. Each
 * time through the loop it accepts a connection and prints out messages
 * from it. When the connection breaks, or a termination message comes
 * through, the program accepts a new connection.
 */
char buf[1024];  /* global rather than auto, so doesn't go on SVC stack */
main()
{
  int                sock,
                     length;
  struct sockaddr_in server;
  int                msgsock;
  int                rval;
  int                i;
  /* Create socket */
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock &lt; 0)
  {
    xperror("opening stream socket");
    exit(1);
  }
  /* Name socket using wildcards */
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port = 0;
  if (bind(sock, &amp;server, sizeof(server)))
  {
    xperror("binding stream socket");
    exit(1);
  }
  /* Find out assigned port number and print it out */
  length = sizeof(server);
  if (getsockname(sock, &amp;server, &amp;length))
  {
    xperror("getting socket name");
    exit(1);
  }
  printf("Socket has port #%d\n", ntohs(server.sin_port));
  /* Start accepting connections */
  listen(sock, 5);
  do
  {
    msgsock = accept(sock, 0, 0);
    if (msgsock == -1)
      xperror("accept");
    else do
    {
      bzero(buf, sizeof(buf));
      if ((rval = socketread(msgsock, buf, 1024)) &lt; 0)
        xperror("reading stream message");
      i = 0;
      if (rval == 0)
        printf("Ending connection\n");
      else
        printf("--&gt;%s\n", buf);
    }
    while (rval != 0);
    close(msgsock);
  }
  while (TRUE);
}</pre></p>
<p align="center">
<i><a name="84601"></a>Accepting an Internet domain stream connection</i></p>
<p>The program in <A HREF="#98658">Using select() to check for pending connections</a> is a slight variation on the server in <A HREF="#84601">Accepting an Internet domain stream connection</a>. It avoids <a name="marker-327730"></a>blocking when there are no pending <a name="marker-328227"></a>connection requests by calling select() to check for pending requests before calling accept(). This strategy is useful when connections may be received on more than one socket, or when data may arrive on other connected sockets before another connection request.</p>
<p><pre>#include &lt;stdio.h&gt;
#include "sys/types.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "netinet/in.h"
#include "netdb.h"
#define TRUE 1
/*
 * This program uses select() to check that someone is trying to connect
 * before calling accept().
 */
char buf[1024];  /* global rather than auto, so doesn't go on SVC stack */
main()
{
  int                sock,
                     length;
  struct sockaddr_in server;
  int                msgsock;
  int                rval;
  fd_set             ready;
  struct timeval     to;
  /* Create socket */
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock &lt; 0)
  {
    xperror("opening stream socket");
    exit(1);
  }
  /* Name socket using wildcards */
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port = 0;
  if (bind(sock, &amp;server, sizeof(server)))
  {
    xperror("binding stream socket");
    exit(1);
  }
  /* Find out assigned port number and print it out */
  length = sizeof(server);
  if (getsockname(sock, &amp;server, &amp;length))
  {
    xperror("getting socket name");
    exit(1);
  }
  printf("Socket has port #%d\n", ntohs(server.sin_port));
  /* Start accepting connections */
  listen(sock, 5);
  do
  {
    FD_ZERO(&amp;ready);
    FD_SET(sock, &amp;ready);
    to.tv_sec = 5;
    if (select(sock + 1, &amp;ready, 0, 0, &amp;to) &lt; 0)
    {
      xperror("select");
      continue;
    }
    if (FD_ISSET(sock, &amp;ready))
    {
      msgsock = accept(sock, (struct sockaddr *) 0, (int *) 0);
      if (msgsock == -1)
        xperror("accept");
      else do
      {
        bzero(buf, sizeof(buf));
        if ((rval = socketread(msgsock,buf,1024)) &lt; 0)
          xperror("reading stream message");
        else if (rval == 0)
          printf("Ending connection\n");
        else
          printf("--&gt;%s\n", buf);
      }
      while (rval &gt; 0);
      close(msgsock);
    }
    else
      printf("Do something else\n");
  }
  while (TRUE);
}</pre><a name="marker-327640"></a><a name="marker-327652"></a><a name="marker-328256"></a></p>
<p align="center">
<i><a name="98658"></a>Using select() to check for pending connections</i></p>
</dl>

<dt>
<h4><a name="idx-5359"></a>Reads, writes, recvs, etc</h4>
<dd>
<dl>
<dd>
<p>Socklib has several system calls for <a name="marker-327810"></a>reading and <a name="marker-327837"></a>writing information. The simplest calls are socketread() and socketwrite(). Socketwrite() takes as arguments the index of a descriptor, a pointer to a buffer containing the data and the size of the data. The descriptor indicates a connected socket. 'Connected' can mean either a connected <a name="marker-327857"></a>stream socket (as described in <A HREF="#59490">Connections</a>) or a <a name="marker-327861"></a>datagram socket for which a connect() call has provided a default destination (see <A HREF="#11499">CONNECT</a>). Socketread() also takes a descriptor that indicates a socket. Socketwrite() requires a connected socket since no destination is specified in the parameters of the system call. Socketread() can be used for either a connected or an unconnected socket. These calls are, therefore, quite flexible and may be used to write applications that require no assumptions about the source of their input or the destination of their output. There are variations on socketread() and socketwrite() that allow the source and destination of the input and output to use several separate buffers. These are socketreadv() and socketwritev(), for read and write vector.</p>
<p>It is sometimes necessary to send high priority data over a connection that may have unread low priority data at the other end. For example, a user interface program may be interpreting commands and sending them on to another program through a <a name="marker-327867"></a>stream connection. The user interface may have filled the stream with as yet unprocessed requests when the user types a command to cancel all outstanding requests. Rather than have the high priority data wait to be processed after the low priority data, it is possible to send it as <a name="marker-327874"></a>out-of-band (OOB) data. The notification of pending OOB data results in the generation of an <a name="marker-327875"></a>Internet event (see <A HREF="#68725">The Internet event</a>). There are a pair of calls similar to socketread and socketwrite that allow options, including sending and receiving OOB information; these are send() and recv(). These calls also allow <a name="marker-327876"></a>peeking at data in a stream. That is, they allow a program to read data without removing the data from the stream. One use of this facility is to read ahead in a stream to determine the size of the next item to be read. When not using these options, these calls have the same functions as socketread() and socketwrite().</p>
<p>To send datagrams, one must be allowed to specify the destination. The call sendto() takes a destination address as an argument and is therefore used for sending datagrams. The call recvfrom() is often used to read datagrams, since this call returns the address of the sender, if it is available, along with the data. If the identity of the sender does not matter, one may use socketread() or recv().</p>
<p>Finally, there are a pair of calls that allow the sending and receiving of messages from multiple buffers, when the address of the recipient must be specified. These are sendmsg() and recvmsg().</p>
<p>The various options for reading and writing are shown in <A HREF="#26488">Varieties of socketread and socketwrite commands</a>, together with their parameters. The parameters for each system call reflect the differences in function of the different calls. In the examples given in this tutorial, the calls socketread() and socketwrite() have been used whenever possible.</p>
<p><pre>/*
 * The variable "sock" must be the descriptor of a socket.
 */
cc = socketread(sock, buf, nbytes)
int cc, sock; char *buf; int nbytes;
/*
 * An iovec can include several source buffers.
 */
cc = socketreadv(sock, iov, iovcnt)
int cc, sock; struct iovec *iov; int iovcnt;
cc = socketwrite(sock, buf, nbytes)
int cc, sock; char *buf; int nbytes;
cc = socketwritev(sock, iovec, ioveclen)
int cc, sock; struct iovec *iovec; int ioveclen;
/*
 * Flags may include MSG_OOB and MSG_PEEK.
 */
cc = send(sock, msg, len, flags)
int cc, sock; char *msg; int len, flags;
cc = sendto(sock, msg, len, flags, to, tolen)
int cc, sock; char *msg; int len, flags;
struct sockaddr *to; int tolen;
cc = sendmsg(sock, msg, flags)
int cc, sock; struct msghdr msg[]; int flags;<a name="marker-327848">
cc = recv(sock, buf, len, flags)
int cc, sock; char *buf; int len, flags;
int cc, sock; char *buf; int len, flags;
struct sockaddr *from; int *fromlen;
cc = recvmsg(sock, msg, flags)
int cc, sock; struct msghdr msg[]; int flags;<a name="marker-327833"></pre></p>
<p align="center">
<i><a name="26488"></a>Varieties of socketread and socketwrite commands</i></p>
</dl>

<dt>
<h4><a name="idx-5360"></a>Choices</h4>
<dd>
<dl>
<dd>
<p>This introductory tutorial has presented examples of some of the forms of communication supported by RISC OS. These have been presented in an order chosen for ease of presentation. It is useful to review these options emphasizing the factors that make each attractive.</p>
<p>The Internet <a name="marker-327877"></a>domain allows communication between machines. This makes the Internet domain a necessary choice for programs running on separate machines.</p>
<p>The choice between <a name="marker-327878"></a>datagrams and <a name="marker-327879"></a>stream communication is best made by carefully considering the semantic and performance requirements of the application. Streams can be both advantageous and disadvantageous. One disadvantage is that a program is only allowed a limited number of open streams, as there are usually only 96 entries available in the system-wide open <a name="marker-327880"></a>descriptor table. This can cause problems if a single server must talk with a large number of clients. Another is that for delivering a short message the stream setup and teardown time can be unnecessarily long. Weighed against this is the reliability built into the streams. This will often be the deciding factor in favour of streams.</p>
</dl>

<dt>
<h4><a name="idx-5361"></a>What to do next</h4>
<dd>
<dl>
<dd>
<p>Many of the examples presented here can serve as models for multiprocess programs and for programs distributed across several machines. In developing a new multiprocess program, it is often easiest to first write the code to create the programs and communication paths. After this code is debugged, the code specific to the application can be added.</p>
</dl>

<dt>
<h2><a name="67890"></a>Advanced tutorial</h2>

<dt>
<h4><a name="idx-5362"></a>Introduction</h4>
<dd>
<dl>
<dd>
<p>This section gives you a more advanced tutorial on the communications programming facilities provided by the Internet module. It looks at the overall model for communication, outlines the communications primitives we've provided, and (in particular) looks at how to use these primitives in developing applications.</p>
<p>This tutorial provides a high-level description of the communications facilities and their use. It is complements the descriptions of the library calls later in this chapter by examples of their use. The remainder of this section is organized in parts:</p>
<ul>
<li><A HREF="#47388">Basics</a> introduces the communication-related calls and the basic model of communication.
<li><A HREF="#16914">Network library routines</a> describes some of the supporting library routines users may find useful in constructing distributed applications.
<li><A HREF="#40406">Client/server model</a> is concerned with the client/server model used in developing applications, and includes examples of the two major types of servers.
<li><A HREF="#68725">The Internet event</a> describes the Internet event which is used by a number of important features, such as asynchronous I/O, and out-of-band data.
<li><A HREF="#52479">Advanced topics</a> delves into advanced topics which sophisticated users are likely to encounter when using the communications facilities.
<li><A HREF="#63340">Multitasking</a> outlines how to ensure that programs using the Internet module multitask correctly under RISC OS. <b>It is essential that you read this section and follow its recommendations</b>.
</ul>
<p>You should be familiar with the C programming language, as all examples are written in C.</p>
</dl>

<dt>
<h4><a name="47388"></a>Basics</h4>
<dd>
<dl>
<dd>
<p>The basic building block for communication is the <a name="marker-327483"></a><a name="marker-312068"></a><i>socket</i>. A socket is an endpoint of communication to which you can <i>bind</i> a <a name="marker-312070"></a>name. Each socket in use has a <a name="marker-312071"></a><i>type</i>.</p>
<p>Sockets exist within <a name="marker-312072"></a><i>communication domains</i><a name="marker-312073"></a>. A communication domain is an abstraction introduced to bundle common properties of programs communicating through sockets. One such property is the scheme used to name sockets. Sockets normally exchange data only with sockets in the same domain. (It may be possible to cross domain boundaries, but only if some translation process is performed.)</p>
<p>The RISC OS socket subsystem currently only supports a single communication domain: the <a name="marker-312075"></a><i>Internet domain</i>, which is used by programs which communicate using the DARPA standard communication protocols.<a name="marker-312076"></a></p>

<dt>
<h5><a name="idx-5363"></a>Socket types</h5>
<dd>
<p><a name="marker-312079"></a>Sockets are typed according to the communication properties visible to a user. Programs are presumed to communicate only between sockets of the same type, although there is nothing that prevents communication between sockets of different types should the underlying communication protocols support this.</p>
<p>Three types of sockets currently are available to a user.</p>
<ul>
<li>A <i><a name="marker-312082"></a>stream</i> socket provides for the bidirectional, reliable, sequenced, and unduplicated flow of data without record boundaries. (Aside from the bidirectionality of data flow, a pair of connected stream sockets provides an interface nearly identical to that of BSD UNIX pipes.)
<li>A <i><a name="marker-312084"></a>datagram</i> socket supports bidirectional flow of data which is not promised to be sequenced, reliable, or unduplicated. That is, a program receiving messages on a datagram socket may find messages duplicated, and, possibly, in an order different from the order in which it was sent. An important characteristic of a datagram socket is that record boundaries in data are preserved. Datagram sockets closely model the facilities found in many contemporary packet switched networks such as the Ethernet.
<li>A <a name="marker-312086"></a>raw socket provides users access to the underlying communication protocols which support socket abstractions. These sockets are normally datagram oriented, though their exact characteristics are dependent on the interface provided by the protocol. Raw sockets are not intended for the general user; they have been provided mainly for those interested in developing new communication <a name="marker-327968"></a>protocols, or for gaining access to some of the more esoteric facilities of an existing protocol. The use of raw sockets is considered in <A HREF="#94807">Selecting specific protocols</a>.
</ul>

<dt>
<h5><a name="idx-5364"></a>Socket creation</h5>
<dd>
<p>To <a name="marker-327974"></a>create a socket the socket system call is used:</p>
<dl>
<dd>
<pre>s = socket(domain, type, protocol);</pre>
</dl>
<p>This call requests that the system create a socket in the specified domain and of the specified type. A particular <i>protocol</i> may also be requested.</p>
<ul>
<li>The <a name="marker-312640"></a>domain is specified as one of the manifest constants defined in the file "sys/socket.h". The manifest constants are named AF_... as they indicate the 'address format' to use in interpreting names; for the Internet domain supported by RISC OS the constant is <a name="marker-312642"></a>AF_INET.
<li>The <a name="marker-312643"></a>socket types are also defined in this file and one of SOCK_STREAM, SOCK_DGRAM, or SOCK_RAW must be specified.
<li>If the <a name="marker-327985"></a>protocol is left unspecified (a <a name="marker-312691"></a>value of 0), the system will select an appropriate protocol from those protocols which comprise the communication domain and which may be used to support the requested socket type.
</ul>
<p>The user is returned a <a name="marker-312696"></a>descriptor (a small integer number) which may be used in later system calls which operate on sockets.</p>
<p>To create a <a name="marker-327167"></a>stream socket in the Internet domain the following call might be used:</p>
<dl>
<dd>
<pre>s = socket(AF_INET, SOCK_STREAM, 0);</pre>
</dl>
<p>This call would result in a stream socket being created with the <a name="marker-327983"></a>TCP protocol providing the underlying communication support. To create a <a name="marker-327984"></a>datagram socket for the Internet domain use the call might be:</p>
<dl>
<dd>
<pre>s = socket(AF_INET, SOCK_DGRAM, 0);</pre>
</dl>
<p>The default protocol (used when the protocol argument to the socket call is 0) should be correct for most every situation. However, it is possible to specify a protocol other than the default; this is covered in <A HREF="#94807">Selecting specific protocols</a>.</p>
<p>There are several reasons a socket call may fail. Aside from the rare occurrence of lack of memory (<a name="marker-312708"></a>ENOBUFS), a socket request may fail due to a request for an unknown protocol (<a name="marker-312709"></a>EPROTONOSUPPORT), or a request for a type of socket for which there is no supporting protocol (<a name="marker-312710"></a>EPROTOTYPE).<a name="marker-312711"></a></p>

<dt>
<h5><a name="idx-5365"></a>Binding local names</h5>
<dd>
<p>A <a name="marker-312671"></a>socket is created without a name. Until a name is bound to a socket, programs have no way to reference it and, consequently, no messages may be received on it. Communicating programs are bound by an association. In the Internet domain, an association is composed of local and foreign <a name="marker-327381"></a><a name="marker-312681"></a>Internet addresses, and local and foreign <a name="marker-312686"></a>port numbers. In most domains, associations must be unique. In the Internet domain there may never be duplicate &lt;protocol, local address, local port, foreign address, foreign port&gt; tuples.</p>
<p>The bind system call allows a program to specify half of an association, &lt;local address, local port&gt;, while the connect and accept primitives are used to complete a socket's association.</p>
<p>In the Internet domain, binding names to sockets can be fairly complex. Fortunately, it is usually not necessary to specifically bind an address and port number to a socket, because the connect and send calls will automatically bind an appropriate address if they are used with an unbound socket.</p>
<p>The bind system call is used as follows:</p>
<dl>
<dd>
<pre>bind(s, name, namelen);</pre>
</dl>
<p>The bound name is a variable length byte string which is interpreted by the supporting protocol(s). Its interpretation may vary from communication <a name="marker-327995"></a>domain to communication domain (this is one of the properties which comprise the domain). As mentioned, in the Internet domain names contain an Internet address and port number. If one wanted to bind an Internet address, the following code would be used:</p>
<dl>
<dd>
<pre>#include "sys/types.h"
#include "netinet/in.h"
...
struct sockaddr_in sin;
...
bind(s, (struct sockaddr *) &amp;sin, sizeof(sin));</pre>
</dl>
<p>but the selection of what to place in the address sin requires some discussion. We will come back to the problem of formulating Internet addresses in <A HREF="#16914">Network library routines</a>, when the library routines used in name resolution are discussed.<a name="marker-327988"></a></p>

<dt>
<h5><a name="idx-5366"></a>Connection establishment</h5>
<dd>
<p><a name="marker-327997"></a>Connection establishment is usually asymmetric, with one program a <i>client</i><a name="marker-312758"></a> and the other a <i>server</i><a name="marker-312763"></a>.</p>
<ul>
<li>The server, when willing to offer its advertised services, binds a socket to a well-known address associated with the service and then passively 'listens' on its socket.
<p>It is then possible for an unrelated program to rendezvous with the server.</p>
<li>The client requests services from the server by initiating a 'connection' to the server's socket.
</ul>
<p>On the client side the connect call is used to initiate a <a name="marker-327484"></a><a name="marker-312773"></a>connection. Using the Internet domain, this might appear as:</p>
<dl>
<dd>
<pre>struct sockaddr_in server;
...
connect(s, (struct sockaddr *) &amp;server, sizeof(server));</pre>
</dl>
<p>where server in the example above contains the <a name="marker-328007"></a>Internet address and <a name="marker-328008"></a>port number of the server to which the client program wishes to speak.</p>
<p>If the client program's socket is unbound at the time of the connect call, the system will automatically select and bind a <a name="marker-328009"></a>name to the socket if necessary. This is the usual way that local addresses are bound to a socket.</p>
<p>An error is returned if the connection was unsuccessful (any name automatically bound by the system, however, remains). Otherwise, the socket is associated with the server and data transfer may begin. Some of the more common errors returned when a connection attempt fails are:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top"><a name="marker-312793"></a>ETIMEDOUT
<td align="left" valign="top">After failing to establish a connection for a period of time, the system decided there was no point in retrying the connection attempt any more. This usually occurs because the destination host is down, or because problems in the network resulted in transmissions being lost.
<tr>
<td align="left" valign="top"><a name="marker-312798"></a>ECONNREFUSED
<td align="left" valign="top">The host refused service for some reason. This is usually due to a server program not being present at the requested name.
<tr>
<td align="left" valign="top"><a name="marker-312803"></a>ENETDOWN or <a name="marker-312807"></a>EHOSTDOWN
<td align="left" valign="top">These operational errors are returned based on status information delivered to the client host by the underlying communication services.
<tr>
<td align="left" valign="top"><a name="marker-312808"></a>ENETUNREACH or <a name="marker-312809"></a>EHOSTUNREACH
<td align="left" valign="top">These operational errors can occur either because the network or host is unknown (no route to the network or host is present), or because of status information returned by intermediate gateways or switching nodes. Many times the status returned is not sufficient to distinguish a network being down from a host being down, in which case the system indicates the entire network is unreachable.<a name="marker-312783"></a>
</table>
</dl>
<p>For the server to receive a client's <a name="marker-312811"></a>connection it must perform two steps after binding its socket. The first is to indicate a willingness to listen for incoming connection requests:</p>
<dl>
<dd>
<tt>listen(s, 5);</tt>
</dl>
<p>The second parameter to the listen call specifies the maximum number of outstanding connections which may be queued awaiting acceptance by the server program; this number may be limited by the system. Should a connection be requested while the queue is full, the connection will not be refused, but rather the individual messages which comprise the request will be ignored. This gives a harried server time to make room in its pending connection queue while the client retries the connection request. Had the connection been returned with the <a name="marker-328018"></a>ECONNREFUSED error, the client would be unable to tell if the server was up or not. As it is now it is still possible to get the <a name="marker-328019"></a>ETIMEDOUT error back, though this is unlikely. The backlog figure supplied with the listen call is currently limited by the system to a maximum of 5 pending connections on any one queue. This avoids the problem of programs hogging system resources by setting an infinite backlog, then ignoring all connection requests.<a name="marker-328022"></a></p>
<p>With a socket marked as listening, a server may accept a <a name="marker-312834"></a>connection:</p>
<dl>
<dd>
<pre>struct sockaddr_in from;
...
fromlen = sizeof(from);
newsock = accept(s, (struct sockaddr *) &amp;from, &amp;fromlen);</pre>
</dl>
<p>A new <a name="marker-328027"></a>descriptor is returned on receipt of a connection (along with a new socket). If the server wishes to find out who its client is, it may supply a buffer for the client socket's name. The value-result parameter fromlen is initialized by the server to indicate how much space is associated with from, then modified on return to reflect the true size of the name. If the client's name is not of interest, the second parameter may be a null pointer.</p>
<p>Accept normally blocks. That is, accept will not return until a connection is available or the system call is interrupted - for example by Escape being pressed. Further, there is no way for a program to indicate it will accept connections from only a specific individual, or individuals. It is up to the user program to consider who the connection is from and close down the connection if it does not wish to speak to the program. If the server program wants to accept connections on more than one socket, or wants to avoid blocking on the accept call, there are alternatives; they will be considered in <A HREF="#52479">Advanced topics</a>.<a name="marker-312844"></a><a name="marker-312849"></a><a name="marker-312854"></a><a name="marker-327999"></a></p>

<dt>
<h5><a name="idx-5367"></a>Data transfer</h5>
<dd>
<p>With a connection established, data may begin to flow. To <a name="marker-312986"></a>send and <a name="marker-312987"></a>receive data there are a number of possible calls. With the peer entity at each end of a connection anchored, a user can send or receive a message without specifying the peer. In this case the socketread and socketwrite system calls are usable:</p>
<dl>
<dd>
<pre>socketwrite(s, buf, sizeof(buf));
socketread(s, buf, sizeof(buf));</pre>
</dl>
<p>In addition to socketread and socketwrite, the calls send and recv may be used:</p>
<dl>
<dd>
<pre>send(s, buf, sizeof(buf), flags);
recv(s, buf, sizeof(buf), flags);</pre>
</dl>
<p>While send and recv are virtually identical to socketread and socketwrite, the extra flags argument is important. The flags, defined in "sys/socket.h", may be specified as a non-zero value if one or more of the following is required:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">MSG_OOB
<td align="left" valign="top">send/receive out-of-band data
<tr>
<td align="left" valign="top">MSG_PEEK
<td align="left" valign="top">look at data without reading
<tr>
<td align="left" valign="top">MSG_DONTROUTE
<td align="left" valign="top">send data without routing packets
</table>
</dl>
<ul>
<li>Out-of-band data is a notion specific to stream sockets, and one which we will not immediately consider.
<li>The option to have data sent without routing applied to the outgoing packets is currently used only by the routing table management program, and is unlikely to be of interest to the casual user.
<li>The ability to preview data is, however, of interest. When MSG_PEEK is specified with a recv call, any data present is returned to the user, but treated as still 'unread'. That is, the next socketread or recv call applied to the socket will return the data previously previewed.<a name="marker-328038"></a><a name="marker-328044"></a>
</ul>

<dt>
<h5><a name="idx-5368"></a>Discarding sockets</h5>
<dd>
<p>Once a <a name="marker-313029"></a>socket is no longer of interest, it may be discarded by applying a socketclose to the descriptor:</p>
<dl>
<dd>
<pre>socketclose(s);</pre>
</dl>
<p>If data is associated with a socket which promises reliable delivery (eg a stream socket) when a close takes place, the system will continue to attempt to transfer the data. However, after a fairly long period of time, if the data is still undelivered, it will be discarded. <a name="marker-313034"></a>Should a user have no use for any pending data, it may perform a shutdown on the socket prior to closing it. This call is of the form:</p>
<dl>
<dd>
<pre>shutdown(s, how);</pre>
</dl>
<p>where how is 0 if the user is no longer interested in reading data, 1 if no more data will be sent, or 2 if no data is to be sent or received.</p>
<p>When a client or server machine crashes, the socket stays open on the machine that hasn't crashed. Afterwards, under RISC OS, socketwrite or send calls will result in an event being generated (see <A HREF="#68725">The Internet event</a>) and a return error of <a name="marker-328090"></a>EPIPE, socketread or recv calls will return an EOF indication.<a name="marker-328085"></a></p>

<dt>
<h5><a name="idx-5369"></a>Connectionless sockets</h5>
<dd>
<p>To this point we have been concerned mostly with sockets which follow a connection oriented model. However, there is also support for connectionless interactions typical of the datagram facilities found in contemporary packet switched networks. A <a name="marker-313055"></a>datagram socket provides a symmetric interface to data exchange. While programs are still likely to be client and server, there is no requirement for connection establishment. Instead, each message includes the destination address.</p>
<p>Datagram sockets are created as before. If a particular local address is needed, the bind operation must precede the first data transmission. Otherwise, the system will set the local address and/or port when data is first sent.</p>
<p>To <a name="marker-313059"></a>send data, the sendto primitive is used:</p>
<dl>
<dd>
<pre>sendto(s, buf, buflen, flags, (struct sockaddr *) &amp;to, tolen);</pre>
</dl>
<ul>
<li>The s, buf, buflen, and flags parameters are used as before.
<li>The to and tolen values are used to indicate the address of the intended recipient of the message.
</ul>
<p>When using an unreliable datagram interface, it is unlikely that any errors will be reported to the sender. When information is present locally to recognize a message that can not be delivered (for instance when a network is unreachable), the call will return -1 and the global value errno will contain an error number.</p>
<p>To <a name="marker-313065"></a>receive messages on an unconnected datagram socket, the recvfrom primitive is provided:</p>
<dl>
<dd>
<pre>recvfrom(s, buf, buflen, flags, (struct sockaddr *) &amp;from, &amp;fromlen);</pre>
</dl>
<ul>
<li>Once again, the fromlen parameter is handled in a value-result fashion, initially containing the size of the from buffer, and modified on return to indicate the actual size of the address from which the datagram was received.
</ul>
<p>In addition to the two calls mentioned above, datagram sockets may also use the connect call to associate a socket with a specific destination address. In this case, any data sent on the socket will automatically be addressed to the connected peer, and only data received from that peer will be delivered to the user. Only one connected address is permitted for each socket at one time; a second connect will change the destination address, and a connect to a null address (family <a name="marker-313071"></a>AF_UNSPEC) will disconnect. Connect requests on datagram sockets return immediately, as this simply results in the system recording the peer's address (as compared to a stream socket, where a connect request initiates establishment of an end to end connection). <a name="marker-328095"></a>Accept and <a name="marker-328096"></a>listen are not used with datagram sockets.</p>
<p>While a datagram socket is connected, errors from recent send calls may be returned asynchronously. These errors may be reported on subsequent operations on the socket, or a special socket option used with getsockopt, SO_ERROR, may be used to interrogate the error status. A select for reading or writing will return true when an error indication has been received. The next operation will return the error, and the error status is cleared. Other of the less important details of datagram sockets are described in <A HREF="#52479">Advanced topics</a>.<a name="marker-313094"></a></p>

<dt>
<h5><a name="idx-5370"></a>Input/output multiplexing</h5>
<dd>
<p>One last facility often used in developing applications is the ability to multiplex i/o requests among multiple <a name="marker-328265"></a>sockets. This is done using the select call:</p>
<dl>
<dd>
<pre>#include "sys/time.h"
#include "sys/types.h"
...
fd_set readmask, writemask, exceptmask;
struct timeval timeout;
...
select(nfds, &amp;readmask, &amp;writemask, &amp;exceptmask, &amp;timeout);</pre>
</dl>
<p>Select takes as arguments pointers to three sets:</p>
<ul>
<li>one for the set of socket descriptors for which the caller wishes to be able to read data on
<li>one for those descriptors to which data is to be written
<li>one for which exceptional conditions are pending
<p>(Out-of-band data is the only exceptional condition currently implemented by the socket. If the user is not interested in certain conditions - ie read, write, or exceptions - the corresponding argument to the select should be a null pointer.</p>
</ul>
<p>Each set is actually a structure containing an array of long integer bit masks; the size of the array is set by the definition FD_SETSIZE. The array must be long enough to hold one bit for each of FD_SETSIZE descriptors.</p>
<p>The macros FD_SET(fd, &amp;mask) and FD_CLR(fd, &amp;mask) have been provided for adding and removing descriptor fd in the set mask. The set should be zeroed before use, and the macro FD_ZERO(&amp;mask) has been provided to clear the set mask.</p>
<p>The parameter nfds in the select call specifies the range of descriptors (ie one plus the value of the largest descriptor) to be examined in a set.</p>
<p>A timeout value may be specified if the selection is not to last more than a predetermined period of time. If the fields in timeout are set to 0, the selection takes the form of a poll, returning immediately. If the last parameter is a null pointer, the selection will block indefinitely.</p>
<p>Select normally returns the number of descriptors selected; if the select call returns due to the timeout expiring, then the value 0 is returned. If the select terminates because of an error or interruption, a -1 is returned with the error number in errno, and with the socket descriptor masks unchanged.</p>
<p>Assuming a successful return, the three sets will indicate which descriptors are ready to be read from, written to, or have exceptional conditions pending. The status of a socket descriptor in a select mask may be tested with the FD_ISSET(fd, &amp;mask) macro, which returns a non-zero value if fd is a member of the set mask, and 0 if it is not.</p>
<p>To determine if there are connections waiting on a socket to be used with an <a name="marker-328101"></a>accept call, select can be used, followed by a FD_ISSET(fd, &amp;mask) macro to check for read readiness on the appropriate socket. If FD_ISSET returns a non-zero value, indicating permission to read, then a connection is pending on the socket.</p>
<p>As an example, to read data from two sockets, s1 and s2 as it is available from each and with a one-second timeout, the following code might be used:</p>
<dl>
<dd>
<pre>#include "sys/time.h"
#include "sys/types.h"
...
fd_set         read_template;
struct timeval wait;
...
for (;;)
{
  wait.tv_sec = 1;  /* one second */
  wait.tv_usec = 0;
  FD_ZERO(&amp;read_template);
  FD_SET(s1, &amp;read_template);
  FD_SET(s2, &amp;read_template);
  nb = select(FD_SETSIZE, &amp;read_template, (fd_set *) 0, (fd_set *) 0, &amp;wait);
  if (nb &lt;= 0)
  {
    <i>An error occurred during the select, or the select timed out.</i>
  }
  if (FD_ISSET(s1, &amp;read_template))
  {
    <i>Socket #1 is ready to be read from.</i>
  }
  if (FD_ISSET(s2, &amp;read_template))
  {
    <i>Socket #2 is ready to be read from.</i>
  }
}</pre>
</dl>
<p>Select provides a synchronous multiplexing scheme. Asynchronous notification of output completion, input availability, and exceptional conditions is possible through use of the Internet events described in <A HREF="#68725">The Internet event</a>.<a name="marker-328271"></a></p>
</dl>

<dt>
<h4><a name="16914"></a>Network library routines</h4>
<dd>
<dl>
<dd>
<p>The discussion in the previous part of this tutorial indicated the possible need to locate and construct network addresses when using the communication facilities in a distributed environment. To aid in this task a number of routines have been provided in the <a name="marker-313222"></a>Inetlib library. In this section we will consider the routines provided to manipulate network <a name="marker-328133"></a>addresses.</p>
<p>Locating a service on a remote host requires many levels of mapping before client and server may communicate:</p>
<ul>
<li>A service is assigned a name which is intended for human consumption; eg 'the login server on host monet'.
<li>This name, and the name of the peer host, must then be translated into network addresses which are not necessarily suitable for human consumption.
<li>Finally, the address must then used in locating a physical location and route to the service.
</ul>
<p>The specifics of these three mappings are likely to vary between network architectures. For instance, it is desirable for a network to not require hosts to be named in such a way that their physical location is known by the client host. Instead, underlying services in the network may discover the actual location of the host at the time a client host wishes to communicate. This ability to have hosts named in a location independent manner may induce overhead in connection establishment, as a discovery process must take place, but allows a host to be physically mobile without requiring it to notify its clientele of its current location.</p>
<p>Standard routines are provided for mapping:</p>
<ul>
<li>host names to network addresses
<li>network names to network numbers
<li>protocol names to protocol numbers
<li>service names to port numbers and the appropriate protocol to use in communicating with the server program.
</ul>
<p>The file "netdb.h" must be included when using any of these routines.</p>

<dt>
<h5><a name="idx-5371"></a>Host names</h5>
<dd>
<p>An <a name="marker-328146"></a>Internet host name to address mapping is represented by the hostent structure:</p>
<dl>
<dd>
<pre>struct hostent
{
  char  *h_name;       /* official name of host */
  char **h_aliases;   /* alias list */
  int    h_addrtype;    /* host address type (eg AF_INET) */
  int    h_length;      /* length of address */
  char **h_addr_list; /* list of addresses, null terminated */
};
#define h_addr  h_addr_list[0] /* first address, network byte order */</pre>
</dl>
<p>The routine gethostbyname takes an Internet host name and returns a hostent structure, while the routine gethostbyaddr maps Internet host addresses into a hostent structure.</p>
<p>The official name of the host and its public aliases are returned by these routines, along with the address type (family) and a null terminated list of variable length addresses. This list of addresses is required because it is possible for a host to have many addresses, all having the same name. The h_addr definition is provided for backward compatibility, and is defined to be the first address in the list of addresses in the hostent structure.</p>
<p>The database for these calls is provided by the file InetDBase:<a name="marker-327482"></a><a name="marker-313285"></a>hosts. When using gethostbyname, only one address will be returned, but all listed aliases will be included.<a name="marker-328152"></a></p>

<dt>
<h5><a name="idx-5372"></a>Network names</h5>
<dd>
<p>As for host names, routines for mapping <a name="marker-313290"></a>network names to numbers, and back, are provided. These routines return a netent structure:</p>
<dl>
<dd>
<pre>/*
 * Assumption here is that a network number
 * fits in 32 bits -- probably a poor one.
*/
struct netent
{
  char    *n_name;     /* official name of net */
  char    **n_aliases; /* alias list */
  int     n_addrtype;  /* net address type */
  int     n_net;       /* network number, host byte order */
};</pre>
</dl>
<p>The routines getnetbyname, getnetbynumber, and getnetent are the network counterparts to the host routines described above. The routines extract their information from InetDBase:<a name="marker-313298"></a>networks.<a name="marker-328135"></a><a name="marker-328158"></a></p>

<dt>
<h5><a name="idx-5373"></a>Protocol names</h5>
<dd>
<p>For protocols, which are defined in InetDBase:<a name="marker-313306"></a>protocols, the protoent structure defines the <a name="marker-313312"></a><a name="marker-313313"></a>protocol-name mapping used with the routines getprotobyname, getprotobynumber, and getprotoent:</p>
<dl>
<dd>
<pre>struct protoent
{
  char    *p_name;     /* official protocol name */
  char    **p_aliases; /* alias list */
  int     p_proto;     /* protocol number */
};</pre>
</dl>

<dt>
<h5><a name="idx-5374"></a>Service names</h5>
<dd>
<p>Information regarding services is a bit more complicated. A service is expected to reside at a specific <i>port</i><a name="marker-313328"></a> and employ a particular communication protocol. This view is consistent with the Internet domain, but inconsistent with other network architectures. Further, a service may reside on multiple ports. If this occurs, the higher level library routines will have to be bypassed or extended. Services available are contained in the file InetDBase:<a name="marker-313323"></a>services. A service mapping is described by the servent structure:</p>
<dl>
<dd>
<pre>struct servent
{
  char    *s_name;     /* official service name */
  char    **s_aliases; /* alias list */
  int     s_port;      /* port number, network byte order */
  char    *s_proto;    /* protocol to use */
};</pre>
</dl>
<p>The routine getservbyname maps <a name="marker-328285"></a>service names to a servent structure by specifying a service name and, optionally, a qualifying protocol. Thus the call:</p>
<dl>
<dd>
<pre>sp = getservbyname("telnet", (char *) 0);</pre>
</dl>
<p>returns the service specification for a telnet server using any protocol, while the call:</p>
<dl>
<dd>
<pre>sp = getservbyname("telnet", "tcp");</pre>
</dl>
<p>returns only that telnet server which uses the TCP protocol. The routines getservbyport and getservent are also provided. The getservbyport routine has an interface similar to that provided by getservbyname; an optional <a name="marker-313338"></a>protocol name may be specified to qualify lookups.</p>

<dt>
<h5><a name="idx-5375"></a>Miscellaneous</h5>
<dd>
<p>With the support routines described above, an Internet application program should rarely have to deal directly with addresses. This allows services to be developed as much as possible in a network independent fashion. It is clear, however, that purging all network dependencies is very difficult. So long as the user is required to supply network addresses when naming services and sockets there will always some network dependency in a program. For example, the normal code included in client programs, such as the remote login program, is of the form shown in the example program in <A HREF="#18410">Remote login client code</a>. (This example will be considered in more detail in <A HREF="#40406">Client/server model</a>.)</p>
<p>If we wanted to make the remote login program independent of the Internet protocols and addressing scheme we would be forced to add a layer of routines which masked the network dependent aspects from the mainstream login code. For the current facilities available in the system this does not appear to be worthwhile.</p>
<p>Aside from the address-related data base routines, there are several other routines available in the Inetlib and <a name="marker-328335"></a>Unixlib libraries which are of interest to users. These are intended mostly to simplify manipulation of names and addresses. The table below summarizes the Unixlib routines for manipulating variable length byte strings, and the Inetlib routines for handling <a name="marker-328337"></a>byte swapping of network addresses and values:</p>
<dl>
<dd>
<table>
<tr>
<th align="left" valign="top">Call
<th align="left" valign="top">Synopsis
<tr>
<td align="left" valign="top">bcmp(s1, s2, n)
<td align="left" valign="top">compare byte-strings; 0 if same, not 0 otherwise
<tr>
<td align="left" valign="top">bcopy(s1, s2, n)
<td align="left" valign="top">copy n bytes from s1 to s2
<tr>
<td align="left" valign="top">bzero(base, n)
<td align="left" valign="top">zero-fill n bytes starting at base
<tr>
<td align="left" valign="top">htonl(val)
<td align="left" valign="top">convert 32-bit quantity from host to network byte order
<tr>
<td align="left" valign="top">htons(val)
<td align="left" valign="top">convert 16-bit quantity from host to network byte order
<tr>
<td align="left" valign="top">ntohl(val)
<td align="left" valign="top">convert 32-bit quantity from network to host byte order
<tr>
<td align="left" valign="top">ntohs(val)
<td align="left" valign="top">convert 16-bit quantity from network to host byte order
</table>
</dl>
<p>The byte swapping routines are provided because the operating system expects addresses to be supplied in network order. On some architectures, such as ARMs and VAXes, host byte ordering is different than network byte ordering. Consequently, programs are sometimes required to byte swap quantities. The library routines which return network addresses provide them in network order so that they may simply be copied into the structures provided to the system. This implies users should encounter the byte swapping problem only when interpreting network addresses. For example, if an Internet port is to be printed out the following code would be required:</p>
<dl>
<dd>
<pre>printf("port number %d\n", ntohs(sp-&gt;s_port));</pre>
</dl>
<p>On machines where unneeded the byte swapping routines are defined as null macros.<a name="marker-328340"></a><a name="marker-328129"></a></p>
<p><pre>#include &lt;stdio.h&gt;
#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"
#include "netdb.h"
...
main(argc, argv)
  int argc;
  char *argv[];
{
  struct sockaddr_in  server;
  struct servent     *sp;
  struct hostent     *hp;
  int                 s;
  ...
  sp = getservbyname("login", "tcp");
  if (sp == NULL)
  {
    fprintf(stderr, "rlogin: tcp/login: unknown service\n");
    exit(1);
  }
  hp = gethostbyname(argv[1]);
  if (hp == NULL)
  {
    fprintf(stderr, "rlogin: %s: unknown host\n", argv[1]);
    exit(2);
  }
  bzero((char *) &amp;server, sizeof(server));
  bcopy(hp-&gt;h_addr, (char *) &amp;server.sin_addr, hp-&gt;h_length);
  server.sin_family = hp-&gt;h_addrtype;
  server.sin_port = sp-&gt;s_port;
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s &lt; 0)
  {
    xperror("rlogin: socket");
    exit(3);
  }
  ...
  /* Connect does the bind() for us */
  if (connect(s, (char *) &amp;server, sizeof(server)) &lt; 0)
  {
    xperror("rlogin: connect");
    exit(5);
  }
  ...
}</pre></p>
<p align="center">
<i><a name="18410"></a>Remote login client code</i>
</table>
</dl>

<dt>
<h4><a name="40406"></a>Client/server model</h4>
<dd>
<dl>
<dd>
<p>The most commonly used paradigm in constructing distributed applications is the client/server model. In this scheme <a name="marker-328347"></a>client applications request services from a <a name="marker-328348"></a>server program. This implies an asymmetry in establishing communication between the client and server which has been examined in <A HREF="#47388">Basics</a>. In this part of the tutorial we will look more closely at the interactions between client and server, and consider some of the problems in developing client and server applications.</p>
<p>The client and server require a well known set of conventions before service may be rendered (and accepted). This set of conventions comprises a <a name="marker-328360"></a>protocol which must be implemented at both ends of a connection. Depending on the situation, the protocol may be symmetric or asymmetric. In a symmetric protocol, either side may play the master or slave roles. In an asymmetric protocol, one side is immutably recognized as the master, with the other as the slave. An example of a symmetric protocol is the <a name="marker-328361"></a>TELNET protocol used in the Internet for remote terminal emulation. An example of an asymmetric protocol is the Internet file transfer protocol, <a name="marker-328362"></a><a name="marker-328363"></a>FTP. No matter whether the specific protocol used in obtaining a service is symmetric or asymmetric, when accessing a service there is a 'client program' and a 'server program'. We will first consider the properties of server programs, then client programs.<a name="marker-328356"></a></p>
<p>A server program normally <a name="marker-328365"></a>listens at a well known address for service requests. That is, the server program remains dormant until a connection is requested by a client's connection to the server's address. At such a time the server program 'wakes up' and services the client, performing whatever appropriate actions the client requests of it.</p>

<dt>
<h5><a name="idx-5376"></a>Servers</h5>
<dd>
<p>Most servers are accessed at well known Internet addresses. For example, the BSD UNIX remote login server's main loop is of the form shown in <A HREF="#49936">Remote login server</a>. (Although this example is a little strange in not being a RISC OS application, it still contains a number of relevant and useful points.)</p>
<p>The first step taken by the server is to look up its <a name="marker-328364"></a>service definition:</p>
<dl>
<dd>
<pre>sp = getservbyname("login", "tcp");
if (sp == NULL)
{
  fprintf(stderr, "rlogind: tcp/login: unknown service\n");
  exit(1);
}</pre>
</dl>
<p>The result of the getservbyname call is used in later portions of the code to define the Internet port at which it listens for service requests (indicated by a connection).</p>
<p><pre>main(argc, argv)
  int   argc;
  char *argv[]
{
  int                 f;
  struct sockaddr_in  from;
  struct servent     *sp;
  sp = getservbyname("login", "tcp");
  if (sp == NULL)
  {
    fprintf(stderr, "rlogind: tcp/login: unknown service\n");
    exit(1);
  }
  ...
  sin.sin_port = sp-&gt;s_port;
  ...
  f = socket(AF_INET, SOCK_STREAM, 0);
  ...
  if (bind(f, (struct sockaddr *) &amp;sin, sizeof(sin)) &lt; 0)
  {
    ...
  }
  ...
  listen(f, 5);
  for (;;)
  {
    int g, len = sizeof(from);
    g = accept(f, (struct sockaddr *) &amp;from, &amp;len);
    if (g &lt; 0)
    {
      if (errno != EINTR)
        xperror("rlogind: accept");
      continue;
    }
    doit(g, &amp;from);
    close(g);
  }
}</pre></p>
<p align="center">
<i><a name="49936"></a>Remote login server</i></p>
<p>Once a server has established a pristine environment, it creates a socket and begins <a name="marker-328539"></a>accepting service requests. The bind call is required to insure the server listens at its expected location.<a name="marker-328367"></a></p>
<p>The main body of the loop is fairly simple:</p>
<dl>
<dd>
<pre>for (;;)
{
  int g,
      len = sizeof(from);
  g = accept(f, (struct sockaddr *) &amp;from, &amp;len);
  if (g &lt; 0)
  {
    if (errno != EINTR)
      xperror("rlogind: accept");
    continue;
  }
  doit(g, &amp;from);
  close(g);
}</pre>
</dl>
<p>An accept call blocks the server until a client requests service. This call could return a failure status if the call is interrupted, for example by an Escape. Therefore, the return value from accept is checked to insure a connection has actually been established, and an error report is printed if an error has occurred.</p>
<p>With a connection in hand, the server then invokes the main body of the remote login protocol processing. The address of the client is also handed the doit routine because it requires it in authenticating clients.<a name="marker-328350"></a><a name="marker-328375"></a></p>

<dt>
<h5><a name="idx-5377"></a>Clients</h5>
<dd>
<p>The <a name="marker-328379"></a>client side of the remote login service was shown earlier in <A HREF="#18410">Remote login client code</a>. One can see the separate, asymmetric roles of the client and server clearly in the code. The server is a passive entity, listening for client connections, while the client program is an active entity, initiating a connection when invoked.</p>
<p>Let us consider more closely the steps taken by the client remote login program. As in the server program, the first step is to locate the <a name="marker-328472"></a>service definition for a remote login:</p>
<dl>
<dd>
<pre>sp = getservbyname("login", "tcp");
if (sp == NULL)
{
  fprintf(stderr, "rlogin: tcp/login: unknown service\n");
  exit(1);
}</pre>
</dl>
<p>Next the destination <a name="marker-328473"></a>host is looked up with a gethostbyname call:</p>
<dl>
<dd>
<pre>hp = gethostbyname(argv[1])
if (hp == NULL)
{
  fprintf(stderr, "rlogin: %s: unknown host\n", argv[1]);
  exit(2);
}</pre>
</dl>
<p>With this accomplished, all that is required is to establish a connection to the server at the requested host and start up the remote login protocol. The address buffer is cleared, then filled in with the Internet address of the foreign host and the port number at which the login program resides on the foreign host:</p>
<dl>
<dd>
<pre>bzero((char *) &amp;server, sizeof(server));
bcopy(hp-&gt;h_addr, (char *) &amp;server.sin_addr, hp-&gt;h_length);
server.sin_family = hp-&gt;h_addrtype;
server.sin_port = sp-&gt;s_port;</pre>
</dl>
<p>A socket is created, and a <a name="marker-328475"></a>connection initiated. Note that connect implicitly performs a bind call, since s is unbound.</p>
<dl>
<dd>
<pre>s = socket(hp-&gt;h_addrtype, SOCK_STREAM, 0);
if (s &lt; 0)
{
  xperror("rlogin: socket");
  exit(3);
}
...
if (connect(s, (struct sockaddr *) &amp;server, sizeof(server)) &lt; 0)
{
  xperror("rlogin: connect");
  exit(4);
}</pre>
</dl>
<p>The details of the remote login protocol will not be considered here.<a name="marker-328381"></a><a name="marker-328551"></a></p>

<dt>
<h5>Connectionless <a name="marker-328557"></a>servers</h5>
<dd>
<p>While connection-based services are the norm, some services are based on the use of <a name="marker-328556"></a>datagram sockets. One, in particular, is the 4.3BSD UNIX 'rwho' service which provides users with status information for hosts connected to a local area network. This service, while predicated on the ability to <a name="marker-328566"></a>broadcast information to all hosts connected to a particular network, is of interest as an example usage of datagram sockets.</p>
<p>A user on any machine running the rwho server may find out the current status of a machine with the ruptime program. The output
 generated is illustrated in <A HREF="#44640">ruptime output</a>.</p>
<p><pre>arpa    up      9:45,          5 users, load   1.15,   1.39,   1.31
cad     up      2+12:04,       8 users, load   4.67,   5.13,   4.59
calder  up      10:10,         0 users, load   0.27,   0.15,   0.14
dali    up      2+06:28,       9 users, load   1.04,   1.20,   1.65
degas   up      25+09:48,      0 users, load   1.49,   1.43,   1.41
ear     up      5+00:05,       0 users, load   1.51,   1.54,   1.56
ernie   down    0:24
esvax   down    17:04
ingres  down    0:26
kim     up      3+09:16,       8 users, load   2.03,   2.46,   3.11
matisse up      3+06:18,       0 users, load   0.03,   0.03,   0.05
medea   up      3+09:39,       2 users, load   0.35,   0.37,   0.50
merlin  down    19+15:37
miro    up      1+07:20,       7 users, load   4.59,   3.28,   2.12
monet   up      1+00:43,       2 users, load   0.22,   0.09,   0.07
oz      down    16:09
statvax up      2+15:57,       3 users, load   1.52,   1.81,   1.86
ucbvax  up      9:34,          2 users, load   6.08,   5.16,   3.28</pre></p>
<p align="center">
<i><a name="44640"></a>ruptime output</i></p>
<p>Status information for each host is periodically broadcast by rwho server programs on each machine. The same server program also receives the status information and uses it to update a database. This database is then interpreted to generate the status information for each host. Servers operate autonomously, coupled only by the local network and its broadcast capabilities.</p>
<p>Note that the use of broadcast for such a task is fairly inefficient, as all hosts must process each message, whether or not using an rwho server. Unless such a service is sufficiently universal and is frequently used, the expense of periodic broadcasts outweighs the simplicity.</p>
<p>The rwho server, in a simplified form, is pictured in <A HREF="#36970">rwho server</a>. There are two separate tasks performed by the server. The first task is to act as a receiver of status information broadcast by other hosts on the network. This job is carried out in the main loop of the program. Packets <a name="marker-328565"></a>received at the rwho port are interrogated to insure they've been sent by another rwho server program, then are time stamped with their arrival time and used to update a file indicating the status of the host. When a host has not been heard from for an extended period of time, the database interpretation routines assume the host is down and indicate such on the status reports. This algorithm is prone to error as a server may be down while a host is actually up, but serves our current needs.</p>
<p><pre>main()
{
  ...
  sp = getservbyname("who", "udp");
  net = getnetbyname("localnet");
  sin.sin_addr = inet_makeaddr(INADDR_ANY, net);
  sin.sin_port = sp-&gt;s_port;
  ...
  s = socket(AF_INET, SOCK_DGRAM, 0);
  ...
  on = 1;
  if (setsockopt(s, SOL_SOCKET, SO_BROADCAST, &amp;on, sizeof(on)) &lt; 0)
  {
    xperror("setsockopt SO_BROADCAST");
    exit(1);
  }
  bind(s, (struct sockaddr *) &amp;sin, sizeof(sin));
  ...
  onalrm();
  for (;;)
  {
    struct whod wd;
    int cc, whod, len = sizeof(from);
    cc = recvfrom(s, (char *) &amp;wd, sizeof(struct whod), 0, (struct sockaddr *) &amp;from, &amp;len);
    if (cc &lt;= 0)
    {
      if (cc &lt; 0 &amp;&amp; errno != EINTR)
        xperror("rwhod: recv");
      continue;
    }
    if (from.sin_port != sp-&gt;s_port)
    {
      fprintf(stderr, "rwhod: %d: bad from port", ntohs(from.sin_port));
      continue;
    }
    ...
    if (!verify(wd.wd_hostname))
    {
      fprintf(stderr, "rwhod: malformed host name from %x", ntohl(from.sin_addr.s_addr));
      continue;
    }
    (void) sprintf(path, "%s/whod.%s",RWHODIR,wd.wd_hostname);
    whod = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0666);
    ...
    (void) time(&amp;wd.wd_recvtime);
    (void) write(whod, (char *) &amp;wd, cc);
    (void) close(whod);
  }
}
onalrm()
{
  /* Broadcast our status to other rwho servers, and then use
   * OS_CallAfter to re-enter this function after a given interval.
}</pre></p>
<p align="center">
<i><a name="36970"></a>rwho server</i></p>
<p>The second task performed by the server is to supply information regarding the status of its host. This involves periodically acquiring system status information, packaging it up in a message and broadcasting it on the local network for other rwho servers to hear. The supply function onalrm is triggered by a timer, which it sets itself. Locating the system status information is somewhat involved, but uninteresting. Deciding where to transmit the resultant packet is somewhat problematical, however.</p>
<p>Status information must be broadcast on the local network. For networks which do not support the notion of broadcast another scheme must be used to simulate or replace broadcasting. One possibility is to enumerate the known neighbours (based on the status messages received from other rwho servers). This, unfortunately, requires some bootstrapping information, for a server will have no idea what machines are its neighbours until it receives status messages from them. Therefore, if all machines on a net are freshly booted, no machine will have any known neighbours and thus never receive, or send, any status information. This is the identical problem faced by the routing table management program in propagating routing status information. The standard solution, unsatisfactory as it may be, is to inform one or more servers of known neighbours and request that they always communicate with these neighbours. If each server has at least one neighbour supplied to it, status information may then propagate through a neighbour to hosts which are not (possibly) directly neighbours. If the server is able to support networks which provide a broadcast capability, as well as those which do not, then networks with an arbitrary topology may share status information<sup><A HREF="dpt_one">1</a></sup>.</p>
<p>It is important that software operating in a distributed environment not have any site-dependent information compiled into it. This would require a separate copy of the server at each host and make maintenance a severe headache. 4.3BSD attempts to isolate host-specific information from applications by providing system calls which return the necessary information<sup><A HREF="dpt_two">2</a></sup>.</p>
<p>A mechanism exists, in the form of a socketioctl call, for finding the collection of <a name="marker-328572"></a>networks to which a host is directly connected. Further, a local network broadcasting mechanism has been implemented at the socket level. Combining these two features allows a program to broadcast on any directly connected local network which supports the notion of broadcasting in a site independent manner. This allows 4.3BSD to solve the problem of deciding how to propagate status information in the case of rwho, or more generally in broadcasting. Such status information is broadcast to connected networks at the socket level, where the connected networks have been obtained via the appropriate socketioctl calls. The specifics of such broadcastings are complex, however, and will be covered in <A HREF="#72150">Broadcasting and determining network configuration</a>.<a name="marker-328559"></a><a name="marker-328568"></a></p>
<ol>
<li><a name="dpt_one"></a>One must, however, be concerned about 'loops'. That is, if a host is connected to multiple networks, it will receive status information from itself. This can lead to an endless, wasteful, exchange of information.
<li><a name="dpt_two"></a>An example of such a system call is the gethostname call which returns the host's 'official' name.
</ol>
</dl>

<dt>
<h4><a name="68725"></a>The <a name="marker-328585"></a>Internet event</h4>
<dd>
<dl>
<dd>
<p>(This description of the Internet event supersedes the old description given on <A HREF="EVENTS.HTML#77438">Internet event</a>.)</p>
<p>Under 4.3 BSD, signals are used to notify processes of specific events. Under RISC OS, the Internet event performs a similar function:</p>

<h6><a name="idx-5378"></a>Internet event</h6>
<p>R0 = 19<br>
R1 = event subcode:<br>
<dl>
<dd>
1 =&GT; A <A NAME="MARKER-328595"></a>socket has input waiting to be read<br>
2 =&GT; An urgent event has occurred, such as the arrival of <A NAME="MARKER-328601"></a>out-of-band data<br>
3 =&GT; <A NAME="MARKER-328607"></a>socket connection is broken<br>
4 =&GT; A <A NAME="MARKER-328613"></a>RevARP server has replied to a RevARP request
</dl>
R2 = socket descriptor (if R1 = 1, 2, or 3), or IP address of replying server (if R1 = 4)<br>
R3 = IP address of requesting station (if R1 = 4)</p>
<p>This event is generated when certain Internet events occur:</p>
<p><pre>#define Internet_Event       19
#define Socket_Async_Event   1
#define Socket_Urgent_Event  2
#define Socket_Broken_Event  3
#define RarpReply            4</pre></p>
<ul>
<li>The event Internet_Event/Socket_Async_Event allows an event handler within a program to run when a socket has input waiting to be read; normally the event handler will make a recv call to read expected data, or an accept call to receive an expected call.
<li>The event Internet_Event/Socket_Urgent_Event allows an event handler to run if some urgent event, such as the arrival of out-of-band data, occurs.
<li>The event Internet_Event/Socket_Broken_Event allows an event handler to run if a socket connection is broken.
<li>The event Internet_Event/RarpReply allows an event handler to run if a RevARP server has replied to a RevARP request.
</ul>
<p>Note that event subcodes 1, 2 and 3 are approximately equivalent to the UNIX <a name="marker-324814"></a>SIGIO, SIGURG and SIGPIPE signals respectively, and are generated under equivalent circumstances.</p>

<h6><a name="idx-5379"></a>Using the Internet event</h6>
<p>Use of the event facility requires these steps:</p>
<ol>
<li>You must set up an event handler (see <A HREF="EVENTS.HTML#89576">Events</a>), and then claim the event vector using the SWI <A HREF="SOFTVECS.HTML#37631">OS_Claim</a>.
<li>You must enable the Internet event using the SWI <A HREF="EVENTS.HTML#58852">OS_Byte 14</a>.
<li>You must make a <a name="marker-328671"></a>socketioctl FIOASYNC call for every socket that you require to generate the event Internet_Event/Socket_Async_Event:
<dl>
<dd>
<pre>/* Allow receipt of asynchronous I/O events */
#include "sys/ioctl.h"
...
int s;
int on = 1;
...
s = socket(AF_INET, SOCK_STREAM, 0);
...
if (socketioctl(s, FIOASYNC, &amp;on) &lt; 0)
{
  xperror("socketioctl error");
  return(-1);
}
...</pre>
</dl>
</ol>
<p><a name="marker-328609"></a><a name="marker-328617"></a><a name="marker-328642"></a><a name="marker-328650"></a><a name="marker-328656"></a>The Internet module only generates this event for a socket once you've made this call.</p>
</dl>

<dt>
<h4><a name="52479"></a>Advanced topics</h4>
<dd>
<dl>
<dd>
<p>A number of facilities have yet to be discussed. For most users of the communication system the mechanisms already described will suffice in constructing distributed applications. However, others will find the need to utilise some of the features which we consider in this section.</p>

<dt>
<h5><a name="idx-5380"></a>Out-of-band data</h5>
<dd>
<p>The <a name="marker-327172"></a>stream socket abstraction includes the notion of <a name="marker-313656"></a>out-of-band data. Out-of-band data is a logically independent transmission channel associated with each pair of connected stream sockets. Out-of-band data is delivered to the user independently of normal data.</p>
<p>The abstraction defines that the out-of-band data facilities must support he reliable delivery of at least one out-of-band message at a time. This message may contain at least one byte of data, and at least one message may be pending delivery to the user at any one time. For communications protocols which support only in-band signalling (ie the urgent data is delivered in sequence with the normal data), the system normally extracts the data from the normal data stream and stores it separately. This allows users to choose between receiving the urgent data in order and receiving it out of sequence without having to buffer all the intervening data.</p>
<p>It is possible to '<a name="marker-328678"></a>peek' (via MSG_PEEK) at out-of-band data. The Internet event Socket_Urgent_Event (see <A HREF="#68725">The Internet event</a>) is generated when the protocol is notified of its existence. If multiple sockets may have out-of-band data awaiting delivery, a select call for exceptional conditions may be used to determine those sockets with such data pending. Neither the event nor the select indicate the actual arrival of the out-of-band data, but only notification that it is pending.</p>
<p>In addition to the information passed, a logical mark is placed in the data stream to indicate the point at which the out-of-band data was sent. The remote login and remote shell applications use this facility to propagate signals between client and server programs. When a signal flushes any pending output from the remote program(s), all data up to the mark in the data stream is discarded.</p>
<p>To send an out-of-band message the MSG_OOB flag is supplied to a send or sendto calls, while to receive out-of-band data MSG_OOB should be indicated when performing a recvfrom or recv call. To find out if the read pointer is currently pointing at the mark in the data stream, the SIOCATMARK <i>socketioctl</i> is provided:</p>
<dl>
<dd>
<pre>socketioctl(s, SIOCATMARK, &amp;yes);</pre>
</dl>
<p>If yes is a 1 on return, the next read will return data after the mark. Otherwise (assuming out-of-band data has arrived), the next read will provide data sent by the client prior to transmission of the out-of-band signal. The routine used in the remote login program to flush output - for example on an Escape - is shown in <A HREF="#73598">Flushing I/O on receipt of out-of-band data</a> below. It reads the normal data up to the mark (to discard it), then reads the out-of-band byte.</p>
<p><pre>#include "sys/ioctl.h"
#include "sys/file.h"
#include "kernel.h"
#include "swis.h"
...
char waste[BUFSIZ]; /* global rather than auto; doesn't go on SVC stack */
oob()
{
  char             mark;
  _kernel_swi_regs r;
  for (;;)
  {
    if (socketioctl(rem, SIOCATMARK, &amp;mark) &lt; 0)
    {
      xperror("ioctl");
      break;
    }
    if (mark)
      break;
    (void) socketread(rem, waste, sizeof(waste));
  }
  if (recv(rem, &amp;mark, 1, MSG_OOB) &lt; 0)
  {
    xperror("recv");
    ...
  }
  ...
}</pre></p>
<p align="center">
<i><a name="73598"></a>Flushing I/O on receipt of out-of-band data</i></p>
<p>A program may also read or peek at the out-of-band data without first reading up to the mark. This is more difficult when the underlying protocol delivers the urgent data in-band with the normal data, and only sends notification of its presence ahead of time (eg the TCP protocol used to implement streams in the Internet domain). With such protocols, the out-of-band byte may not yet have arrived when a recv is done with the MSG_OOB flag. In that case, the call will return an error of EWOULDBLOCK. Worse, there may be enough in-band data in the input buffer that normal flow control prevents the peer from sending the urgent data until the buffer is cleared. The program must then read enough of the queued data that the urgent data may be delivered.<a name="marker-328680"></a></p>
<p>Certain programs that use multiple bytes of urgent data and must handle multiple urgent signals (eg telnet) need to retain the position of urgent data within the stream. This treatment is available as a socket-level option, SO_OOBINLINE; see setsockopt for usage. With this option, the position of urgent data (the 'mark') is retained, but the urgent data immediately follows the mark within the normal data stream returned without the MSG_OOB flag. Reception of multiple urgent indications causes the mark to move, but no out-of-band data are lost.<a name="marker-313687"></a><a name="marker-328693"></a></p>

<dt>
<h5><a name="94807"></a>Selecting specific protocols</h5>
<dd>
<p>If the third argument to the socket call is 0, socket will select a default <a name="marker-328694"></a>protocol to use with the returned socket of the type requested. The default protocol is usually correct, and alternate choices are not usually available. However, when using '<a name="marker-328695"></a>raw' sockets to communicate directly with lower-level protocols or hardware interfaces, the protocol argument may be important for setting up demultiplexing. For example, raw sockets in the Internet family may be used to implement a new protocol above IP, and the socket will receive packets only for the protocol specified. To obtain a particular protocol one determines the <a name="marker-328702"></a>protocol number as defined within the communication domain. For the Internet domain one may use one of the library routines discussed in section 3, such as getprotobyname:</p>
<dl>
<dd>
<pre>#include "sys/types.h"
#include "sys/socket.h"
#include "netinet/in.h"
#include "netdb.h"
...
pp = getprotobyname("newtcp");
s = socket(AF_INET, SOCK_STREAM, pp-&gt;p_proto);</pre>
</dl>
<p>This would result in a socket s using a stream based connection, but with protocol type of 'newtcp' instead of the default 'tcp.'<a name="marker-328698"></a></p>

<dt>
<h5><a name="78129"></a>Address binding</h5>
<dd>
<p><a name="marker-328703"></a>As was mentioned in the earlier <A HREF="#47388">Basics</a>, binding addresses to sockets in the Internet domain can be fairly complex. As a brief reminder, these associations are composed of local and foreign addresses, and local and foreign ports. <a name="marker-328709"></a>Port numbers are allocated out of separate spaces, one for each system and one for each domain on that system. Through the bind system call, a program may specify half of an association, the &lt;local address, local port&gt; part, while the connect and accept primitives are used to complete a socket's association by specifying the &lt;foreign address, foreign port&gt; part. Since the association is created in two steps the association uniqueness requirement indicated previously could be violated unless care is taken. Further, it is unrealistic to expect user programs to always know proper values to use for the local address and local port since a host may reside on multiple networks and the set of allocated port numbers is not directly accessible to a user.</p>
<p>To simplify local address binding in the Internet domain the notion of a '<a name="marker-328716"></a>wildcard' address has been provided. When an address is specified as <a name="marker-328715"></a>INADDR_ANY (a manifest constant defined in "netinet/in.h"), the system interprets the address as 'any valid address'. For example, to bind a specific port number to a socket, but leave the local address unspecified, the following code might be used:</p>
<dl>
<dd>
<pre>#include "sys/types.h"
#include "netinet/in.h"
...
struct sockaddr_in sin;
...
s = socket(AF_INET, SOCK_STREAM, 0);
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = htonl(INADDR_ANY);
sin.sin_port = htons(MYPORT);
bind(s, (struct sockaddr *) &amp;sin, sizeof(sin));</pre>
</dl>
<p>Sockets with wildcarded local addresses may receive messages directed to the specified port number, and sent to any of the possible addresses assigned to a host. For example, if a host has addresses 128.32.0.4 and 10.0.0.78, and a socket is bound as above, the program will be able to accept connection requests which are addressed to 128.32.0.4 or 10.0.0.78. If a server program wished to only allow hosts on a given network connect to it, it would bind the address of the host on the appropriate network.</p>
<p>In a similar fashion, a local port may be left unspecified (specified as zero), in which case the system will select an appropriate port number for it. For example, to bind a specific local address to a socket, but to leave the local port number unspecified:</p>
<dl>
<dd>
<pre>hp = gethostbyname(hostname);
if (hp == NULL)
{
  ...
}
bcopy(hp-&gt;h_addr, (char *) sin.sin_addr, hp-&gt;h_length);
sin.sin_port = htons(0);
bind(s, (struct sockaddr *) &amp;sin, sizeof(sin));</pre>
</dl>
<p>The system selects the local port number based on two criteria. The first is that '<a name="marker-328717"></a>privileged' Internet ports below IPPORT_RESERVED (1024) must be specifically requested by a program, whereas higher values are used by RISC OS when it chooses a port number, the program not having specified one. The second is that the port number is not currently bound to some other socket. In order to find a free Internet port number in the privileged range the rresvport library routine may be used as follows to return a stream socket with a privileged port number:</p>
<dl>
<dd>
<pre>int lport = IPPORT_RESERVED - 1;
int s;
...
s = rresvport(&amp;lport);
if (s &lt; 0)
{
  if (errno == EAGAIN)
    fprintf(stderr, "socket: all ports in use\n");
  else
    xperror("rresvport: socket");
  ...
}</pre>
</dl>
<p>The restriction on allocating ports was done to allow programs executing in a 'secure' environment to perform authentication based on the originating address and port number. The port number and network address of the machine from which the user is logging in can be determined either by the from result of the accept call, or from the getpeername call.</p>
<p>In certain cases the algorithm used by the system in selecting port numbers is unsuitable for an application. This is because associations are created in a two step process. For example, the Internet file transfer protocol, <a name="marker-328721"></a>FTP, specifies that data connections must always originate from the same local port. However, duplicate associations are avoided by connecting to different foreign ports. In this situation the system would disallow binding the same local address and port number to a socket if a previous data connection's socket still existed. To override the default port selection algorithm, an <a name="marker-328722"></a>option call must be performed prior to address binding:</p>
<dl>
<dd>
<pre>...
int on = 1;
...
setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));
bind(s, (struct sockaddr *) &amp;sin, sizeof(sin));</pre>
</dl>
<p>With the above call, local addresses may be bound which are already in use. This does not violate the uniqueness requirement as the system still checks at connect time to be sure any other sockets with the same local address and port do not have the same foreign address and port. If the association already exists, the error EADDRINUSE is returned.<a name="marker-328705"></a><a name="marker-328711"></a></p>

<dt>
<h5><a name="72150"></a>Broadcasting and determining network configuration</h5>
<dd>
<p>By using a <a name="marker-328728"></a>datagram socket, it is possible to send <a name="marker-328737"></a>broadcast packets on many networks supported by the system. The network itself must support broadcast; the system provides no simulation of broadcast in software. Broadcast messages can place a high load on a network since they force every host on the network to service them. Consequently, the ability to send broadcast packets has been limited to sockets which are explicitly marked as allowing broadcasting. Broadcast is typically used for one of two reasons: it is desired to find a resource on a local network without prior knowledge of its address, or important functions such as routing require that information be sent to all accessible neighbours.</p>
<p>To send a broadcast message, a datagram socket should be created:</p>
<dl>
<dd>
<pre>s = socket(AF_INET, SOCK_DGRAM, 0);</pre>
</dl>
<p>The socket is marked as allowing broadcasting,</p>
<dl>
<dd>
<pre>int on = 1;
setsockopt(s, SOL_SOCKET, SO_BROADCAST, &amp;on, sizeof(on));</pre>
</dl>
<p>and at least a port number should be bound to the socket:</p>
<dl>
<dd>
<pre>sin.sin_family = AF_INET;
sin.sin_addr.s_addr = htonl(INADDR_ANY);
sin.sin_port = htons(MYPORT);
bind(s, (struct sockaddr *) &amp;sin, sizeof(sin));</pre>
</dl>
<p>The destination address of the message to be broadcast depends on the network(s) on which the message is to be broadcast. The Internet domain supports a shorthand notation for broadcast on the local network, the address <a name="marker-328743"></a>INADDR_BROADCAST (defined in "netinet/in.h"). To determine the list of addresses for all reachable neighbours requires knowledge of the networks to which the host is connected. Since this information should be obtained in a host-independent fashion and may be impossible to derive, RISC OS provides a method of retrieving this information from the system data structures. The SIOCGIFCONF <a name="marker-328744"></a>socketioctl call returns the interface configuration of a host in the form of a single ifconf structure; this structure contains a 'data area' which is made up of an array of ifreq structures, one for each network interface to which the host is connected. These structures are defined in "net/if.h" as follows:</p>
<dl>
<dd>
<pre>struct ifconf
{
  int       ifc_len;  /* size of associated buffer */
  union
  {
    caddr_t ifcu_buf;
    struct  ifreq *ifcu_req;
  }
  ifc_ifcu;
};
#define ifc_buf ifc_ifcu.ifcu_buf  /* buffer address */
#define ifc_req ifc_ifcu.ifcu_req  /* array of structures returned */
#define IFNAMSIZ 16
struct ifreq
{
  char    ifr_name[IFNAMSIZ];  /* if name, eg "en0" */
  union
  {
    struct  sockaddr ifru_addr;
    struct  sockaddr ifru_dstaddr;
    struct  sockaddr ifru_broadaddr;
    short   ifru_flags;
    caddr_t ifru_data;
  }
  ifr_ifru;
};
#define ifr_addr      ifr_ifru.ifru_addr      /* address */
#define ifr_dstaddr   ifr_ifru.ifru_dstaddr   /* other end of p-to-p link */
#define ifr_broadaddr ifr_ifru.ifru_broadaddr /* broadcast address */
#define ifr_flags     ifr_ifru.ifru_flags     /* flags */
#define ifr_data      ifr_ifru.ifru_data      /* for use by interface */</pre>
</dl>
<p>The actual call which obtains the interface configuration is</p>
<dl>
<dd>
<pre>struct ifconf ifc;
char          buf[BUFSIZ];
ifc.ifc_len = sizeof(buf);
ifc.ifc_buf = buf;
if (socketioctl(s, SIOCGIFCONF, (char *) &amp;ifc) &lt; 0)
{
  ...
}</pre>
</dl>
<p>After this call buf will contain one ifreq structure for each network to which the host is connected, and ifc.ifc_len will have been modified to reflect the number of bytes used by the ifreq structures.</p>
<p>For each structure there exists a set of 'interface flags' which tell whether the network corresponding to that interface is up or down, point to point or broadcast, etc. The SIOCGIFFLAGS socketioctl retrieves these flags for an interface specified by an ifreq structure as follows:</p>
<dl>
<dd>
<pre>struct ifreq *ifr;
ifr = ifc.ifc_req;
for (n = ifc.ifc_len / sizeof(struct ifreq); --n &gt;= 0; ifr++)
{
  /*
   * We must be careful that we don't use an interface
   * devoted to an address family other than those intended;
   * if we were interested in NS interfaces, the
   * AF_INET would be AF_NS.
   */
  if (ifr-&gt;ifr_addr.sa_family != AF_INET)
    continue;
  if (ioctl(s, SIOCGIFFLAGS, (char *) ifr) &lt; 0)
  {
    ...
  }
  /*
   * Skip boring cases.
   */
  if ((ifr-&gt;ifr_flags &amp; IFF_UP) == 0 ||
      (ifr-&gt;ifr_flags &amp; IFF_LOOPBACK) ||
      (ifr-&gt;ifr_flags &amp; (IFF_BROADCAST | IFF_POINTTOPOINT)) == 0)
          continue;</pre>
</dl>
<p>Once the flags have been obtained, the broadcast address must be obtained. In the case of broadcast networks this is done via the SIOCGIFBRDADDR socketioctl, while for point-to-point networks the address of the destination host is obtained with SIOCGIFDSTADDR.</p>
<dl>
<dd>
<pre>struct sockaddr dst;
if (ifr-&gt;ifr_flags &amp; IFF_POINTTOPOINT)
{
  if (socketioctl(s, SIOCGIFDSTADDR, (char *) ifr) &lt; 0)
  {
    ...
  }
  bcopy((char *) ifr-&gt;ifr_dstaddr, (char *) &amp;dst, sizeof(ifr-&gt;ifr_dstaddr));
}
else if (ifr-&gt;ifr_flags &amp; IFF_BROADCAST)
{
  if (socketioctl(s, SIOCGIFBRDADDR, (char *) ifr) &lt; 0)
  {
    ...
  }
  bcopy((char *) ifr-&gt;ifr_broadaddr, (char *) &amp;dst, sizeof(ifr-&gt;ifr_broadaddr));
}</pre>
</dl>
<p>After the appropriate socketioctl's have obtained the broadcast or destination address (now in dst), the sendto call may be used:</p>
<dl>
<dd>
<pre>sendto(s, buf, buflen, 0, (struct sockaddr *) &amp;dst, sizeof(dst));</pre>
</dl>
<p>In the above loop one sendto occurs for every interface to which the host is connected that supports the notion of broadcast or point-to-point addressing. If a program only wished to send broadcast messages on a given network, code similar to that outlined above would be used, but the loop would need to find the correct destination address.</p>
<p>Received broadcast messages contain the sender's address and port, as datagram sockets are bound before a message is allowed to go out.<a name="marker-328733"></a><a name="marker-328739"></a></p>

<dt>
<h5><a name="idx-5381"></a>Socket options</h5>
<dd>
<p>It is possible to set and get a number of <a name="marker-328745"></a>options on sockets via the setsockopt and getsockopt system calls. These options include such things as marking a socket for broadcasting, not to route, to linger on close, etc. The general forms of the calls are:</p>
<dl>
<dd>
<pre>setsockopt(s, level, optname, optval, optlen);</pre>
</dl>
<p>and</p>
<dl>
<dd>
<pre>getsockopt(s, level, optname, optval, optlen);</pre>
</dl>
<p>The parameters to the calls are as follows: s is the socket on which the option is to be applied. Level specifies the protocol layer on which the option is to be applied; in most cases this is the 'socket level', indicated by the symbolic constant SOL_SOCKET, defined in "sys/socket.h". The actual option is specified in optname, and is a symbolic constant also defined in "sys/socket.h". Optval and optlen point to the value of the option (in most cases, whether the option is to be turned on or off), and the length of the value of the option, respectively. For getsockopt, optlen is a value-result parameter, initially set to the size of the storage area pointed to by optval, and modified upon return to indicate the actual amount of storage used.</p>
<p>An example should help clarify things. It is sometimes useful to determine the <a name="marker-328751"></a>type (eg stream, datagram, etc) of an existing socket; programs under inetd (described below) may need to perform this task. This can be accomplished as follows via the SO_TYPE socket option and the getsockopt call:</p>
<dl>
<dd>
<pre>#include "sys/types.h"
#include "sys/socket.h"
int type,
    size;
size = sizeof(int);
if (getsockopt(s, SOL_SOCKET, SO_TYPE, (char *) &amp;type, &amp;size) &lt; 0)
{
  ...
}</pre>
</dl>
<p>After the getsockopt call, type will be set to the value of the socket type, as defined in "sys/socket.h". If, for example, the socket were a datagram socket, type would have the value corresponding to SOCK_DGRAM.<a name="marker-328747"></a></p>
</dl>

<dt>
<h4><a name="63340"></a>Multitasking</h4>
<dd>
<dl>
<dd>
<p><a name="marker-326625"></a>The examples in this tutorial - and in the earlier <A HREF="#69869">Introductory tutorial</a> - assume that they are written for a pre-emptive multitasking environment such as Unix. In such cases, it doesn't matter if a call may not return for an arbitrary length of time, as it will not prevent other software from running. However, RISC OS is a co-operative multitasking environment, which relies on a program returning control to the operating system before other programs can run. It is therefore vital that all the calls that your program makes immediately return control to you.</p>
<p>These are the different ways you can do this:</p>
<ul>
<li>Before making a call that might block, call <a name="marker-328755"></a><a href="#44018">select</a> with a zero timeout to determine if the socket is ready for the call. If the socket is ready, then make the call. Otherwise give back control to RISC OS, and retry later on.
<li>Before you first use a socket, mark it as <a name="marker-328756"></a><A HREF="#45872">non-blocking</a>. Any call that would otherwise block no longer does so, but instead returns an <a name="marker-328757"></a>EWOULDBLOCK error. If you get that error returned, you should give back control to RISC OS, and retry later on.
<li><a name="marker-328759"></a>Use the <a name="marker-328758"></a>Internet event to receive notification of when data is available on a socket, and an appropriate event handler to handle the resultant I/O - which will not block, since it does not have to wait for data. The event handler must be in a module so that it is paged into memory when the event occurs.
<p>See <A HREF="#15170">Interrupt driven socket I/O</a>, and <A HREF="#68725">The Internet event</a>.</p>
<p>Some of the above methods require you to give back control to RISC OS, and retry later on:</p>
<li>With a desktop application, you do so by calling Wimp_Poll; however, there is no guarantee how long it will be until control returns to your application.
<li>An alternative is to use OS_CallAfter or OS_CallEvery to arrange for an address to be called after a given time delay; in this case, the address must be within a module so that it is paged in when called.
</ul>

<dt>
<h5><a name="45872"></a>Non-blocking sockets</h5>
<dd>
<p>When writing modules, or programs to run under the Wimp, you may often find it convenient to make use of <a name="marker-324846"></a>sockets which do not block. That is, I/O requests which cannot complete immediately and would therefore cause the program to be suspended awaiting completion are not executed, and an error code is returned. Once a <a name="marker-324847"></a>socket has been created via the socket call, it may be marked as non-blocking by socketioctl as follows:</p>
<dl>
<dd>
<pre>#include "sys/ioctl.h"
...
int s;
int on = 1;
...
s = socket(AF_INET, SOCK_STREAM, 0);
...
if (socketioctl(s, FIONBIO, &amp;on) &lt; 0)
{
  xperror("socketioctl");
  return(-1);
}
...</pre>
</dl>
<p>When performing non-blocking I/O on sockets, one must be careful to check for the error <a name="marker-324852"></a>EWOULDBLOCK (stored in the global variable errno), which occurs when an operation would normally block, but the socket it was performed on is marked as non-blocking. In particular, accept, connect, send, recv, read, and write can all return <a name="marker-328768"></a>EWOULDBLOCK, and programs should be prepared to deal with such return codes. If an operation such as a send cannot be done in its entirety, but partial writes are sensible (for example, when using a stream socket), the data that can be sent immediately will be processed, and the return value will indicate the amount actually sent.<a name="marker-328779"></a></p>

<dt>
<h5><a name="15170"></a>Interrupt driven socket I/O</h5>
<dd>
<p><a name="marker-328787"></a>The event <i>Internet_Event/Socket_Async_Event</i> allows a program to be notified via an event when a socket has data waiting to be read. The steps required to use the <i>Socket_Async_Event</i> facility are described in <A HREF="#68725">The Internet event</a>.</p>
<p>Sample code to allow a given program to receive information on pending I/O requests as they occur for a socket s is given in <A HREF="#80227">Use of asynchronous notification of I/O requests</a>. With the addition of code to the handler to process the <i>Socket_Urgent_Event</i> event subcode, this code can also be used to prepare for receipt of <a name="marker-328793"></a><i>Internet_Event/Socket_Urgent_Event</i> events.</p>
<p><pre>#include "kernel.h"
#include "swis.h"
main(char *argv, int argc)
{
  if (claim_eventv())
    exit(1);  /* Failed immediately, so nothing to tidy */
  if (event_enable())
  {
    disable_release_eventv();  /* Release events etc */
    exit(2);
  }
  /* Event handler now installed and working */
  ...
  disable_release_eventv(); /* On exit */
  exit(0)
}
static _kernel_oserror *claim_eventv(void)
{
  _kernel_swi_regs r;
  r.r[0] = EventV;
  r.r[1] = (int) event_entry_name;  /* entry veneer compiled by CMHG */
  r.r[2] = (int) module_wsp;
  return (_kernel_swi(XOS_Bit | OS_Claim, &amp;r, &amp;r));
}
static _kernel_oserror *event_enable(void)
{
  _kernel_swi_regs r;
  r.r[0] = Event_Enable;
  r.r[1] = Internet_Event;
  return (_kernel_swi(XOS_Bit | OS_Byte, &amp;r, &amp;r));
}
static void disable_release_eventv(void)
{
  _kernel_swi_regs r;
  r.r[0] = Event_Disable;
  r.r[1] = Internet_Event;
  (void) _kernel_swi(OS_Byte, &amp;r, &amp;r);
  r.r[0] = EventV;
  r.r[1] = (int) event_entry_name;  /*entry veneer compiled by CMHG*/
  r.r[2] = (int) module_wsp;
  (void) _kernel_swi(XOS_Bit | OS_Release, &amp;r, &amp;r);
  return;
}
int Internet_event_handler(_kernel_swi_regs *r, void *pw)
{
/*
 * cmhg event handler, for which event_entry_name is the veneer function
 *
 * Parameters:
 *              r  : pointer to registers block
 *              pw : "R12" value established by module initialisation
 * Returns:
 *              0  =&gt; interrupt "claimed"
 *              !0 =&gt; interrupt not "claimed"
 */
  UNUSED(pw);
  /* cmhg will only pass through this event anyway */
  if (r-&gt;r[0] == Internet_Event)
  {
    /* if notification of asynchronous I/O */
    if (r-&gt;r[1] == Socket_Async_Event &amp;&amp;
       (r-&gt;r[2] == my_atpsock || r-&gt;r[2] == my_routedsock))
    {
      process_input(r-&gt;r[2]);
      return 0;
    }
  }
  return 1;
}
static void process_input(int sock)
{
/*
 * Process input on a socket: event has been received to indicate I/O is
 * "available" on this socket
 */
        ...
}<a name="marker-326618"></a><a name="marker-326631"></a><a name="marker-328789"></a></pre></p>
<p align="center">
<i><a name="80227"></a>Use of asynchronous notification of I/O requests</i></p>
</dl>

<dt>
<h2><a name="51065"></a><a name="marker-306978"></a>Protocols</h2>
<dt>
<hr><h2 align="right"><a name="idx-5382"></a>ICMP</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5383"></a>Name</h5>
<dd>
<p><a name="marker-303414"></a>ICMP - <a name="marker-303415"></a>Internet Control Message Protocol</p>

<dt>
<h5><a name="idx-5384"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
int socket(AF_INET, SOCK_RAW, proto);
int proto;</pre></p>

<dt>
<h5><a name="idx-5385"></a>Description</h5>
<dd>
<p>ICMP is the error and control message protocol used by IP and the Internet protocol family. It may be accessed through a 'raw socket' for network monitoring and diagnostic functions. The <i>proto</i> parameter to the socket call to create an ICMP socket is obtained from <i>getprotobyname</i>. ICMP sockets are connectionless, and are normally used with the <i>sendto</i> and <i>recvfrom</i> calls, though the <i>connect</i> call may also be used to fix the destination for future packets (in which case the <i>recv</i> and <i>send</i> system calls may be used).</p>
<p>Outgoing packets automatically have an IP header prepended to them (based on the destination address). Incoming packets are received with the IP header and options intact.</p>
<p>A socket operation may fail with one of the following errors returned:</p>
<dl>
<dd>
<p>[<a name="marker-303430"></a>EISCONN] when trying to establish a connection on a socket which already has one, or when trying to send a datagram with the destination address specified and the socket is already connected;</p>
<p>[<a name="marker-303432"></a>ENOTCONN] when trying to send a datagram, but no destination address is specified, and the socket hasn't been connected;</p>
<p>[<a name="marker-303434"></a>ENOBUFS] when the system runs out of memory for an internal data structure;</p>
<p>[<a name="marker-303436"></a>EADDRNOTAVAIL] when an attempt is made to create a socket with a network address for which no network interface exists.<a name="marker-328805"></a></p>
</dl>
</dl>
<dt>
<hr><h2 align="right"><a name="idx-5386"></a>IP</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5387"></a>Name</h5>
<dd>
<p><a name="marker-303440"></a>IP - <a name="marker-303441"></a>Internet Protocol</p>

<dt>
<h5><a name="idx-5388"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
int socket(AF_INET, SOCK_RAW, proto);
int proto;</pre></p>

<dt>
<h5><a name="idx-5389"></a>Description</h5>
<dd>
<p>IP is the <a name="marker-303446"></a>transport layer protocol used by the Internet protocol family. Options may be set at the IP level when using higher-level protocols that are based on IP (such as <a name="marker-303449"></a>TCP and <a name="marker-303450"></a>UDP). It may also be accessed through a 'raw socket' when developing new protocols, or special purpose applications.</p>
<p>A single generic option is supported at the IP level, IP_OPTIONS, that may be used to provide IP options to be transmitted in the IP header of each outgoing packet. Options are set with <i>setsockopt</i> and examined with <i>getsockopt</i>. The format of IP options to be sent is that specified by the IP protocol specification, with one exception: the list of addresses for Source Route options must include the first-hop gateway at the beginning of the list of gateways. The first-hop gateway address will be extracted from the option list and the size adjusted accordingly before use. IP options may be used with any socket type in the Internet family.</p>
<p>Raw IP sockets are connectionless, and are normally used with the <i>sendto</i> and <i>recvfrom</i> calls, though the <i>connect</i> call may also be used to fix the destination for future packets (in which case the <i>recv</i> and <i>send</i> system calls may be used).</p>
<p>If <i>proto</i> is 0, the default protocol IPPROTO_RAW is used for outgoing packets, and only incoming packets destined for that protocol are received. If <i>proto</i> is non-zero, that protocol number will be used on outgoing packets and to filter incoming packets.</p>
<p>If <i>proto</i> is IPPROTO_RAW (or 0, which defaults to that) outgoing packets do not have an IP header prepended to them, but go out 'as is'. Otherwise outgoing packets automatically have an IP header prepended to them (based on the destination address and the protocol number the socket is created with). Incoming packets are received with IP header and options intact.</p>
<p>A socket operation may fail with one of the following errors returned:</p>
<dl>
<dd>
<p>[<a name="marker-303465"></a>EISCONN] when trying to establish a connection on a socket which already has one, or when trying to send a datagram with the destination address specified and the socket is already connected;</p>
<p>[<a name="marker-303467"></a>ENOTCONN] when trying to send a datagram, but no destination address is specified, and the socket hasn't been connected;</p>
<p>[<a name="marker-303469"></a>ENOBUFS] when the system runs out of memory for an internal data structure;</p>
<p>[<a name="marker-303471"></a>EADDRNOTAVAIL] when an attempt is made to create a socket with a network address for which no network interface exists.</p>
</dl>
<p>The following errors specific to IP may occur when setting or getting IP options:</p>
<dl>
<dd>
<p>[<a name="marker-303474"></a>EINVAL] an unknown socket option name was given;</p>
<p>[<a name="marker-303476"></a>EINVAL] the IP option field was improperly formed; an option field was shorter than the minimum value or longer than the option buffer provided.<a name="marker-303478"></a></p>
</dl>
</dl>
<dt>
<hr><h2 align="right"><a name="idx-5390"></a>TCP</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5391"></a>Name</h5>
<dd>
<p><a name="marker-327180"></a>TCP - Internet <a name="marker-326947"></a>Transmission Control Protocol</p>

<dt>
<h5><a name="idx-5392"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
int socket(AF_INET, SOCK_STREAM, 0);</pre></p>

<dt>
<h5><a name="idx-5393"></a>Description</h5>
<dd>
<p>The TCP protocol provides reliable, flow-controlled, two-way transmission of data. It is a byte-stream protocol used to support the SOCK_STREAM abstraction. TCP uses the standard Internet address format and, in addition, provides a per-host collection of 'port addresses'. Thus, each address is composed of an Internet address specifying the host and network, with a specific TCP port on the host identifying the peer entity.</p>
<p>Sockets utilising the tcp protocol are either 'active' or 'passive'. Active sockets initiate connections to passive sockets. By default TCP sockets are created active; to create a passive socket the <i>listen</i> socket call must be used after binding the socket with the <i>bind</i> system call. Only passive sockets may use the <i>accept</i> call to accept incoming connections. Only active sockets may use the <i>connect</i> call to initiate connections.</p>
<p>Passive sockets may 'underspecify' their location to match incoming connection requests from multiple networks. This technique, termed '<a name="marker-303496"></a>wildcard addressing', allows a single server to provide service to clients on multiple networks. To create a socket which listens on all networks, the Internet address <a name="marker-303497"></a>INADDR_ANY must be bound. The TCP port may still be specified at this time; if the port is not specified the system will assign one. Once a connection has been established the socket's address is fixed by the peer entity's location. The address assigned to the socket is the address associated with the network interface through which packets are being transmitted and received. Normally this address corresponds to the peer entity's network.</p>
<p>TCP supports one socket option which is set with <i>setsockopt</i> and tested with <i>getsockopt</i>. Under most circumstances, TCP sends data when it is presented; when outstanding data has not yet been acknowledged, it gathers small amounts of output to be sent in a single packet once an acknowledgement is received. For a small number of clients, such as window systems that send a stream of mouse events which receive no replies, this packetisation may cause significant delays. Therefore, TCP provides a boolean option, TCP_NODELAY, to defeat this algorithm. The option level for the <i>setsockopt</i> call is the protocol number for TCP, available from <i>getprotobyname</i>.</p>
<p>Options at the IP transport level may be used with TCP. Incoming connection requests that are source-routed are noted, and the reverse source route is used in responding.</p>
<p>A socket operation may fail with one of the following errors returned:</p>
<dl>
<dd>
<p>[<a name="marker-303506"></a>EISCONN]                                when trying to establish a connection on a socket which already has one;</p>
<p>[<a name="marker-303508"></a>ENOBUFS]                                when the system runs out of memory for an internal data structure;</p>
<p>[<a name="marker-303510"></a>ETIMEDOUT]                              when a connection was dropped due to excessive retransmissions;</p>
<p>[<a name="marker-303512"></a>ECONNRESET]                             when the remote peer forces the connection to be closed;</p>
<p>[<a name="marker-303514"></a>ECONNREFUSED]                           when the remote peer actively refuses connection establishment (usually because no program is listening to the port);</p>
<p>[<a name="marker-303516"></a>EADDRINUSE]                             when an attempt is made to create a socket with a port which has already been allocated;</p>
<p>[<a name="marker-303518"></a>EADDRNOTAVAIL]                          when an attempt is made to create a socket with a network address for which no network interface exists.<a name="marker-327191"></a></p>
</dl>
</dl>
<dt>
<hr><h2 align="right"><a name="idx-5394"></a>UDP</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5395"></a>Name</h5>
<dd>
<p><a name="marker-303523"></a>UDP - Internet <a name="marker-326939"></a>User Datagram Protocol</p>

<dt>
<h5><a name="idx-5396"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
int socket(AF_INET, SOCK_DGRAM, 0);</pre></p>

<dt>
<h5><a name="idx-5397"></a>Description</h5>
<dd>
<p>UDP is a simple, unreliable datagram protocol which is used to support the SOCK_DGRAM abstraction for the Internet protocol family. UDP sockets are connectionless, and are normally used with the <i>sendto</i> and <i>recvfrom</i> calls, though the connect call may also be used to fix the destination for future packets (in which case the <i>recv</i> and <i>send</i> system calls may be used).</p>
<p>UDP address formats are identical to those used by <a name="marker-303536"></a>TCP. In particular UDP provides a port identifier in addition to the normal Internet address format. Note that the UDP port space is separate from the TCP port space (ie a UDP port may not be 'connected' to a TCP port). In addition <a name="marker-303538"></a>broadcast packets may be sent (assuming the underlying network supports this) by using a reserved 'broadcast address'; this address is network interface dependent.</p>
<p>Options at the <a name="marker-303539"></a>IP transport level may be used with UDP.</p>
<p>A socket operation may fail with one of the following errors returned:</p>
<dl>
<dd>
<p>[<a name="marker-303542"></a>EISCONN]                                when trying to establish a connection on a socket which already has one, or when trying to send a datagram with the destination address specified and the socket is already connected;</p>
<p>[<a name="marker-303544"></a>ENOTCONN]                               when trying to send a datagram, but no destination address is specified, and the socket hasn't been connected;</p>
<p>[<a name="marker-303546"></a>ENOBUFS]                                when the system runs out of memory for an internal data structure;</p>
<p>[<a name="marker-303548"></a>EADDRINUSE]                             when an attempt is made to create a socket with a port which has already been allocated;</p>
<p>[<a name="marker-303550"></a>EADDRNOTAVAIL]                          when an attempt is made to create a socket with a network address for which no network interface exists.<a name="marker-303552"></a><a name="marker-328861"></a></p>
</dl>
</dl>

<dt>
<h2><a name="marker-328871"></a><a name="marker-328872"></a><a name="marker-328873"></a><a name="90856"></a>Library calls</h2>
<dt>
<hr><h2 align="right"><a name="35650"></a><a name="marker-328884"></a><a name="marker-328890"></a><a name="marker-328896"></a>INDEX</h2>
<dd>
<dl>
<dd>
<p>The following symbols are exported by Socklib, Inetlib and Unixlib:</p>
<dl>
<dd>
<table>
<tr>
<th align="left" valign="top">Symbol
<th align="left" valign="top">from
<th align="left" valign="top">See
<tr>
<td align="left" valign="top">accept
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#10536">ACCEPT</a>
<tr>
<td align="left" valign="top">access
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#89782">ACCESS</a>
<tr>
<td align="left" valign="top">bcmp
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#43338">BSTRING</a>
<tr>
<td align="left" valign="top">bcopy
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#43338">BSTRING</a>
<tr>
<td align="left" valign="top">bind
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#36015">BIND</a>
<tr>
<td align="left" valign="top">bzero
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#43338">BSTRING</a>
<tr>
<td align="left" valign="top">chdir
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#45729">CHDIR</a>
<tr>
<td align="left" valign="top">chmod
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#55281">CHMOD</a>
<tr>
<td align="left" valign="top">close
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#93405">CLOSE</a>
<tr>
<td align="left" valign="top">connect
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#11499">CONNECT</a>
<tr>
<td align="left" valign="top">endhostent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#57988">GETHOSTBYNAME</a>
<tr>
<td align="left" valign="top">endnetent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#83249">GETNETENT</a>
<tr>
<td align="left" valign="top">endprotoent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#36948">GETPROTOENT</a>
<tr>
<td align="left" valign="top">endpwent
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#23667">GETPWENT</a>
<tr>
<td align="left" valign="top">endservent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#34645">GETSERVENT</a>
<tr>
<td align="left" valign="top">errno
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="MODULES.HTML#90260">ERRNO</a>
<tr>
<td align="left" valign="top">filestat
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#73224">FILESTAT</a>
<tr>
<td align="left" valign="top">flushinput
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#55858">FLUSHINPUT</a>
<tr>
<td align="left" valign="top">fstat
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#46060">FSTAT</a>
<tr>
<td align="left" valign="top">getdtablesize
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#81046">GETDTABLESIZE</a>
<tr>
<td align="left" valign="top">getegid
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#14661">GETEGID</a>
<tr>
<td align="left" valign="top">geteuid
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#67596">GETUID</a>
<tr>
<td align="left" valign="top">getgroups
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#93158">GETGROUPS</a>
<tr>
<td align="left" valign="top">gethostbyaddr
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#57988">GETHOSTBYNAME</a>
<tr>
<td align="left" valign="top">gethostbyname
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#57988">GETHOSTBYNAME</a>
<tr>
<td align="left" valign="top">gethostent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#57988">GETHOSTBYNAME</a>
<tr>
<td align="left" valign="top">gethostname
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#61210">GETHOSTNAME</a>
<tr>
<td align="left" valign="top">getlogin
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#42987">GETLOGIN</a>
<tr>
<td align="left" valign="top">getnetbyaddr
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#83249">GETNETENT</a>
<tr>
<td align="left" valign="top">getnetbyname
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#83249">GETNETENT</a>
<tr>
<td align="left" valign="top">getnetent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#83249">GETNETENT</a>
<tr>
<td align="left" valign="top">getpass
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#46888">GETPASS</a>
<tr>
<td align="left" valign="top">getpeername
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#99966">GETPEERNAME</a>
<tr>
<td align="left" valign="top">getpid
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#17008">GETPID</a>
<tr>
<td align="left" valign="top">getprotobyname
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#36948">GETPROTOENT</a>
<tr>
<td align="left" valign="top">getprotobynumber
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#36948">GETPROTOENT</a>
<tr>
<td align="left" valign="top">getprotoent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#36948">GETPROTOENT</a>
<tr>
<td align="left" valign="top">getpwent
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#23667">GETPWENT</a>
<tr>
<td align="left" valign="top">getpwnam
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#23667">GETPWENT</a>
<tr>
<td align="left" valign="top">getpwuid
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#23667">GETPWENT</a>
<tr>
<td align="left" valign="top">getservbyname
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#34645">GETSERVENT</a>
<tr>
<td align="left" valign="top">getservbyport
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#34645">GETSERVENT</a>
<tr>
<td align="left" valign="top">getservent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#34645">GETSERVENT</a>
<tr>
<td align="left" valign="top">getsockname
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#45457">GETSOCKNAME</a>
<tr>
<td align="left" valign="top">getsockopt
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#91651">GETSOCKOPT</a>
<tr>
<td align="left" valign="top">getstablesize
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#32962">GETSTABLESIZE</a>
<tr>
<td align="left" valign="top">gettimeofday
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#23005">GETTIMEOFDAY</a>
<tr>
<td align="left" valign="top">getuid
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#67596">GETUID</a>
<tr>
<td align="left" valign="top">getvarhostname
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#59461">GETVAR</a>
<tr>
<td align="left" valign="top">getvarusername
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#59461">GETVAR</a>
<tr>
<td align="left" valign="top">getwd
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#76464">GETWD</a>
<tr>
<td align="left" valign="top">herror
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#44268">HERROR</a>
<tr>
<td align="left" valign="top">_host_stayopen
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#57988">GETHOSTBYNAME</a>
<tr>
<td align="left" valign="top">htonl
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#33123">BYTEORDER</a>
<tr>
<td align="left" valign="top">htons
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#33123">BYTEORDER</a>
<tr>
<td align="left" valign="top">index
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#52893">STRING</a>
<tr>
<td align="left" valign="top">inet_addr
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#44336">INET</a>
<tr>
<td align="left" valign="top">_inet_error
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#90429">_INET_ERROR</a>
<tr>
<td align="left" valign="top">inet_lnaof
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#44336">INET</a>
<tr>
<td align="left" valign="top">inet_makeaddr
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#44336">INET</a>
<tr>
<td align="left" valign="top">inet_netof
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#44336">INET</a>
<tr>
<td align="left" valign="top">inet_network
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#44336">INET</a>
<tr>
<td align="left" valign="top">inet_ntoa
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#44336">INET</a>
<tr>
<td align="left" valign="top">ioctl
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#97822">IOCTL</a>
<tr>
<td align="left" valign="top">killfile
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#78807">KILLFILE</a>
<tr>
<td align="left" valign="top">listen
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#75746">LISTEN</a>
<tr>
<td align="left" valign="top">lseek
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#18572">LSEEK</a>
<tr>
<td align="left" valign="top">_makecall
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#48705">_MAKECALL</a>
<tr>
<td align="left" valign="top">namisipadr
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#71667">NAMISIPADR</a>
<tr>
<td align="left" valign="top">_net_stayopen
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#83249">GETNETENT</a>
<tr>
<td align="left" valign="top">ntohl
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#33123">BYTEORDER</a>
<tr>
<td align="left" valign="top">ntohs
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#33123">BYTEORDER</a>
<tr>
<td align="left" valign="top">osreadc
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#30442">OSREADC</a>
<tr>
<td align="left" valign="top">_proto_stayopen
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#36948">GETPROTOENT</a>
<tr>
<td align="left" valign="top">_pwbuf
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#10604">_PWBUF</a>
<tr>
<td align="left" valign="top">read
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#77996">READ</a>
<tr>
<td align="left" valign="top">readdir
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#19983">READDIR</a>
<tr>
<td align="left" valign="top">readv
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#77996">READ</a>
<tr>
<td align="left" valign="top">recv
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#32246">RECV</a>
<tr>
<td align="left" valign="top">recvfrom
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#32246">RECV</a>
<tr>
<td align="left" valign="top">recvmsg
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#32246">RECV</a>
<tr>
<td align="left" valign="top">rindex
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#52893">STRING</a>
<tr>
<td align="left" valign="top">rresvport
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#99734">RRESVPORT</a>
<tr>
<td align="left" valign="top">select
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#44018">SELECT</a>
<tr>
<td align="left" valign="top">send
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#79679">SEND</a>
<tr>
<td align="left" valign="top">sendmsg
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#79679">SEND</a>
<tr>
<td align="left" valign="top">sendto
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#79679">SEND</a>
<tr>
<td align="left" valign="top">_serv_stayopen
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#34645">GETSERVENT</a>
<tr>
<td align="left" valign="top">sethostent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#57988">GETHOSTBYNAME</a>
<tr>
<td align="left" valign="top">setnetent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#83249">GETNETENT</a>
<tr>
<td align="left" valign="top">setprotoent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#36948">GETPROTOENT</a>
<tr>
<td align="left" valign="top">setpwent
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#23667">GETPWENT</a>
<tr>
<td align="left" valign="top">setservent
<td align="left" valign="top">Inetlib
<td align="left" valign="top"><A HREF="#34645">GETSERVENT</a>
<tr>
<td align="left" valign="top">setsockopt
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#91651">GETSOCKOPT</a>
<tr>
<td align="left" valign="top">shutdown
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#57581">SHUTDOWN</a>
<tr>
<td align="left" valign="top">socket
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#85806">SOCKET</a>
<tr>
<td align="left" valign="top">socketclose
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#77741">SOCKETCLOSE</a>
<tr>
<td align="left" valign="top">socketioctl
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#99356">SOCKETIOCTL</a>
<tr>
<td align="left" valign="top">socketread
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#50260">SOCKETREAD</a>
<tr>
<td align="left" valign="top">socketreadv
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#50260">SOCKETREAD</a>
<tr>
<td align="left" valign="top">socketstat
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#11589">SOCKETSTAT</a>
<tr>
<td align="left" valign="top">socketwrite
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#10379">SOCKETWRITE</a>
<tr>
<td align="left" valign="top">socketwritev
<td align="left" valign="top">Socklib
<td align="left" valign="top"><A HREF="#10379">SOCKETWRITE</a>
<tr>
<td align="left" valign="top">strcasecmp
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#52893">STRING</a>
<tr>
<td align="left" valign="top">strncasecmp
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#52893">STRING</a>
<tr>
<td align="left" valign="top">sys_errlist
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#64687">XPERROR</a>
<tr>
<td align="left" valign="top">sys_nerr
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#64687">XPERROR</a>
<tr>
<td align="left" valign="top">unlink
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#83611">UNLINK</a>
<tr>
<td align="left" valign="top">_varnamebuf
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#34430">_VARNAMEBUF</a>
<tr>
<td align="left" valign="top">write
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#63426">WRITE</a>
<tr>
<td align="left" valign="top">writev
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#63426">WRITE</a>
<tr>
<td align="left" valign="top">xgets
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#92110">XGETS</a>
<tr>
<td align="left" valign="top">xperror
<td align="left" valign="top">Unixlib
<td align="left" valign="top"><A HREF="#64687">XPERROR</a>
<tr>
<td align="left" valign="top">xput
<td align="left" valign="top">Uni
<td align="left" valign="top"><A HREF="#35693">XPUTCHAR</a><a name="marker-328886"></a><a name="marker-328892"></a><a name="marker-328898">
</table>
</dl>
</dl>
<dt>
<hr><h2 align="right"><a name="10536"></a>ACCEPT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5398"></a>Name</h5>
<dd>
<p><a name="marker-302057"></a>accept - accept a connection on a socket</p>

<dt>
<h5><a name="idx-5399"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
#include "sys/types.h"
int accept(s, addr, addrlen)
int s;
struct sockaddr *addr;
int *addrlen;</pre></p>

<dt>
<h5><a name="idx-5400"></a>Description</h5>
<dd>
<p>The argument <i>s</i> is a socket that has been created with <i>socket</i>, bound to an address with <i>bind</i>, and is listening for connections after a <i>listen</i>. <i>Accept</i> extracts the first connection on the queue of pending connections, creates a new socket with the same properties of <i>s</i>, and allocates a new socket descriptor for the socket. If no pending connections are present on the queue, and the socket is not marked as non-blocking, <i>accept</i> blocks the caller until a connection is present. If the socket is marked non-blocking and no pending connections are present on the queue, <i>accept</i> returns an error as described below. The accepted socket may not be used to accept more connections. The original socket <i>s</i> remains open.</p>
<p>The argument <i>addr</i> is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer. The exact format of the <i>addr</i> parameter is determined by the domain in which the communication is occurring (eg Internet). The <i>addrlen</i> is a value-result parameter; it should initially contain the amount of space pointed to by <i>addr</i>; on return it will contain the actual length (in bytes) of the address returned. This call is used with connection-based socket types, currently with SOCK_STREAM.</p>

<dt>
<h5><a name="idx-5401"></a>Return value</h5>
<dd>
<p>The call returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the accepted socket.</p>

<dt>
<h5><a name="idx-5402"></a>Errors</h5>
<dd>
<p>The call will fail if:</p>
<dl>
<dd>
<p>[<a name="marker-302071"></a>EBADF] The descriptor is invalid.</p>
<p>[<a name="marker-302073"></a>EOPNOTSUPP] The referenced socket is not of type SOCK_STREAM.</p>
<p>[<a name="marker-302075"></a>EFAULT] The <i>addr</i> parameter is invalid.</p>
<p>[<a name="marker-302077"></a>EWOULDBLOCK] The socket is marked non-blocking and no connections are present to be accepted.</p>
</dl>

<dt>
<h5><a name="idx-5403"></a>See also</h5>
<dd>
<p><A HREF="#36015">BIND</a>, <A HREF="#11499">CONNECT</a>, <A HREF="#75746">LISTEN</a>, <A HREF="#44018">SELECT</a>, <A HREF="#85806">SOCKET</a></p>

<dt>
<h5><a name="idx-5404"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-328909"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="89782"></a>ACCESS</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5405"></a>Name</h5>
<dd>
<p>access - determine accessibility of <a name="marker-328927"></a>file</p>

<dt>
<h5><a name="idx-5406"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/fcntl.h"
#define R_OK 4  /* test for read permission */
#define W_OK 2  /* test for write permission */
#define X_OK 1  /* execute permission, ignored */
#define F_OK 0  /* test for presence of file */
int access(path, mode)
char *path;
int mode;</pre></p>

<dt>
<h5><a name="idx-5407"></a>Description</h5>
<dd>
<p>Access checks the given file path for accessibility according to mode, which is an inclusive or of the bits R_OK, W_OK and X_OK, defined in sys/fcntl.h. Specifying mode as F_OK (ie 0) tests whether the directories leading to the file can be searched and the file exists.</p>
<p>Notice that only access bits are checked. A directory may be indicated as writable by access, but an attempt to open it for writing will fail (although files may be created there); a file may look executable, but executing it will fail unless it is in proper format.</p>

<dt>
<h5><a name="idx-5408"></a>Return value</h5>
<dd>
<p>If path cannot be found or if any of the desired access modes would not be granted, then a -1 value is returned; otherwise a 0 value is returned.</p>

<dt>
<h5><a name="idx-5409"></a>Errors</h5>
<dd>
<p>Access to the file is denied if one or more of the following are true:</p>
<dl>
<dd>
<p>[<a name="marker-328936"></a>ENOENT]                         The named file does not exist.</p>
<p>[<a name="marker-328937"></a>EACCES]                         Permission bits of the file mode do not permit the requested access. The permission is checked with respect to the 'owner' read and write mode bits.</p>
</dl>

<dt>
<h5><a name="idx-5410"></a>See also</h5>
<dd>
<p><A HREF="#55281">CHMOD</a>, <A HREF="#73224">FILESTAT</a></p>

<dt>
<h5><a name="idx-5411"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-328932"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="36015"></a>BIND</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5412"></a>Name</h5>
<dd>
<p>bind - bind a <a name="marker-328917"></a>name to a socket</p>

<dt>
<h5><a name="idx-5413"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
#include "sys/types.h"
int bind(s, name, namelen)
int s;
struct sockaddr *name;
int namelen;</pre></p>

<dt>
<h5><a name="idx-5414"></a>Description</h5>
<dd>
<p><i>Bind</i> assigns a name to an unnamed socket. When a socket is created with <i>socket</i> it exists in a name space (address family) but has no name assigned. <i>Bind</i> requests that <i>name</i> be assigned to the socket.</p>
<p>The rules used in name binding vary between communication domains.</p>

<dt>
<h5><a name="idx-5415"></a>Return value</h5>
<dd>
<p>If the bind is successful, a 0 value is returned. A return value of -1 indicates an error, which is further specified in the global <i>errno</i>.</p>

<dt>
<h5><a name="idx-5416"></a>Errors</h5>
<dd>
<p>The call will fail if:</p>
<dl>
<dd>
<p>[<a name="marker-302092"></a>EBADF] <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-302094"></a>EADDRNOTAVAIL] The specified address is not available from the local machine.</p>
<p>[<a name="marker-302096"></a>EADDRINUSE] The specified address is already in use.</p>
<p>[<a name="marker-302098"></a>EINVAL] The socket is already bound to an address.</p>
<p>[<a name="marker-302100"></a>EFAULT] The name parameter is invalid.</p>
</dl>

<dt>
<h5><a name="idx-5417"></a>See also</h5>
<dd>
<p><A HREF="#11499">CONNECT</a>, <A HREF="#75746">LISTEN</a>, <A HREF="#85806">SOCKET</a>, <A HREF="#45457">GETSOCKNAME</a></p>

<dt>
<h5><a name="idx-5418"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-328923"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="43338"></a>BSTRING</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5419"></a>Name</h5>
<dd>
<p><a name="marker-328940"></a>bcmp, <a name="marker-328946"></a>bcopy, <a name="marker-328952"></a>bzero - byte string operations</p>

<dt>
<h5><a name="idx-5420"></a>Synopsis</h5>
<dd>
<p><pre>void bcopy(src, dst, length)
char *src, *dst;
int length;
int bcmp(b1, b2, length)
char *b1, *b2;
int length;
char *bzero(b, length)
char *b;
int length;</pre></p>

<dt>
<h5><a name="idx-5421"></a>Description</h5>
<dd>
<p>The functions <i>bcopy</i>, <i>bcmp</i> and <i>bzero</i> operate on variable length strings of bytes. They do not check for null bytes as the routines in <i>string</i> do.</p>
<p><i>Bcopy</i> copies <i>length</i> bytes from string <i>src</i> to the string <i>dst</i>.</p>
<p><i>Bcmp</i> compares byte string <i>b1</i> against byte string <i>b2</i>, returning zero if they are identical, non-zero otherwise. Both strings are assumed to be <i>length</i> bytes long.</p>
<p><i>Bzero</i> places <i>length</i> null (0) bytes in the string <i>b</i>.</p>

<dt>
<h5><a name="idx-5422"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-328942"></a><a name="marker-328948"></a><a name="marker-328954"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="33123"></a>BYTEORDER</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5423"></a>Name</h5>
<dd>
<p>htonl, htons, ntohl, ntohs - convert values between host and network <a name="marker-328964"></a>byte order</p>

<dt>
<h5><a name="idx-5424"></a>Synopsis</h5>
<dd>
<p><pre>int htons(hostshort);
int hostshort;
int ntohs(netshort);
int netshort;
#include "sys/types.h"
u_long htonl(hostlong);
u_long hostlong;
u_long ntohl(netlong);
u_long netlong;</pre></p>

<dt>
<h5><a name="idx-5425"></a>Description</h5>
<dd>
<p>These routines convert 16 and 32 bit quantities between <a name="marker-327353"></a>network byte order and <a name="marker-327355"></a>host byte order.</p>
<p>These routines are most often used in conjunction with Internet addresses and ports as returned by <i>gethostbyname</i> and <i>getservent</i>.</p>

<dt>
<h5><a name="idx-5426"></a>See also</h5>
<dd>
<p><A HREF="#57988">GETHOSTBYNAME</a>, <A HREF="#34645">GETSERVENT</a></p>

<dt>
<h5><a name="idx-5427"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-328970"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="45729"></a>CHDIR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5428"></a>Name</h5>
<dd>
<p>chdir - change <a name="marker-328994"></a>current working <a name="marker-328975"></a>directory</p>

<dt>
<h5><a name="idx-5429"></a>Synopsis</h5>
<dd>
<p><pre>int chdir(path)
char *path;</pre></p>

<dt>
<h5><a name="idx-5430"></a>Description</h5>
<dd>
<p>Path is the pathname of a directory. Chdir causes this directory to become the current working directory, the starting point for incomplete path names. If path specifies a different filing system, it also selects that as the current filing system. If path is a null string, the directory is set to the <a name="marker-329003"></a>user root directory.</p>

<dt>
<h5><a name="idx-5431"></a>Return value</h5>
<dd>
<p>Upon completion, a value of 0 is returned.</p>

<dt>
<h5><a name="idx-5432"></a>Errors</h5>
<dd>
<p>Chdir will fail and the current working directory will be unchanged if the named directory does not exist.</p>

<dt>
<h5><a name="idx-5433"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329009"></a><a name="marker-329016"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="55281"></a>CHMOD</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5434"></a>Name</h5>
<dd>
<p>chmod - change mode of <a name="marker-329020"></a>file</p>

<dt>
<h5><a name="idx-5435"></a>Synopsis</h5>
<dd>
<p><pre>int chmod(path, mode)
char *path;
int mode;</pre></p>

<dt>
<h5><a name="idx-5436"></a>Description</h5>
<dd>
<p>The file whose name is given by path has its read and write attributes changed to those in mode. Modes are constructed by or'ing together some combination of the following:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">IREAD
<td align="left" valign="top">00400
<td align="left" valign="top">read by owner
<tr>
<td align="left" valign="top">IWRITE
<td align="left" valign="top">00200
<td align="left" valign="top">write by owner
</table>
</dl>
<p>Other bits acted on by the Unix version of this command are ignored.</p>

<dt>
<h5><a name="idx-5437"></a>Return value</h5>
<dd>
<p>Upon successful completion, a value of 0 is returned. Otherwise, a value of -1 is returned and errno is set to indicate the error.</p>

<dt>
<h5><a name="idx-5438"></a>Errors</h5>
<dd>
<p>Chmod will fail and the file mode will be unchanged if:</p>
<p>[ENOENT]                             The named file does not exist.</p>

<dt>
<h5><a name="idx-5439"></a>See also</h5>
<dd>
<p><A HREF="#89782">ACCESS</a></p>

<dt>
<h5><a name="idx-5440"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329022"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="93405"></a>CLOSE</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5441"></a>Name</h5>
<dd>
<p><a name="marker-329026"></a>close - delete a descriptor</p>

<dt>
<h5><a name="idx-5442"></a>Synopsis</h5>
<dd>
<p><pre>int close(d)
int d;</pre></p>

<dt>
<h5><a name="idx-5443"></a>Description</h5>
<dd>
<p>Close is a synonym for socketclose; see <A HREF="#77741">SOCKETCLOSE</a>. The call is provided mainly so that you do not need to rename close calls in code that you are porting.</p>

<dt>
<h5><a name="idx-5444"></a>See also</h5>
<dd>
<p><A HREF="#77741">SOCKETCLOSE</a></p>

<dt>
<h5><a name="idx-5445"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329028"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="11499"></a>CONNECT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5446"></a>Name</h5>
<dd>
<p>connect - initiate a <a name="marker-302105"></a>connection on a socket</p>

<dt>
<h5><a name="idx-5447"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
#include "sys/types.h"
int connect(s, name, namelen)
int s;
struct sockaddr *name;
int namelen;</pre></p>

<dt>
<h5><a name="idx-5448"></a>Description</h5>
<dd>
<p>The parameter <i>s</i> is a socket. If it is of type SOCK_DGRAM, then this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type SOCK_STREAM, then this call attempts to make a connection to another socket. The other socket is specified by <i>name</i>, which is an address in the communications space of the socket. Each communications space interprets the <i>name</i> parameter in its own way. Generally, stream sockets may successfully <i>connect</i> only once; datagram sockets may use <i>connect</i> multiple times to change their association. Datagram sockets may dissolve the association by connecting to an invalid address, such as a null address.</p>

<dt>
<h5><a name="idx-5449"></a>Return value</h5>
<dd>
<p>If the connection or binding succeeds, then 0 is returned. Otherwise a -1 is returned, and a more specific error code is stored in <i>errno</i>.</p>

<dt>
<h5><a name="idx-5450"></a>Errors</h5>
<dd>
<p>The call fails if:</p>
<dl>
<dd>
<p>[<a name="marker-302115"></a>EBADF] <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-302117"></a>EADDRNOTAVAIL] The specified address is not available on this machine.</p>
<p>[<a name="marker-302119"></a>EAFNOSUPPORT] Addresses in the specified address family cannot be used with this socket.</p>
<p>[<a name="marker-302121"></a>EISCONN] The socket is already connected.</p>
<p>[<a name="marker-302123"></a>ETIMEDOUT] Connection establishment timed out without establishing a connection.</p>
<p>[<a name="marker-302125"></a>ECONNREFUSED] The attempt to connect was forcefully rejected.</p>
<p>[<a name="marker-302127"></a>ENETUNREACH] The network isn't reachable from this host.</p>
<p>[<a name="marker-302129"></a>EADDRINUSE] The address is already in use.</p>
<p>[<a name="marker-302131"></a>EFAULT] The <i>name</i> parameter was invalid.</p>
<p>[<a name="marker-302133"></a>EINPROGRESS] The socket is non-blocking and the connection cannot be completed immediately.</p>
<p>[<a name="marker-302135"></a>EALREADY] The socket is non-blocking and a previous connection attempt has not yet been completed.</p>
</dl>

<dt>
<h5><a name="idx-5451"></a>See also</h5>
<dd>
<p><A HREF="#10536">ACCEPT</a>, <A HREF="#44018">SELECT</a>, <A HREF="#85806">SOCKET</a>, <A HREF="#45457">GETSOCKNAME</a></p>

<dt>
<h5><a name="idx-5452"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329053"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="90260"></a>ERRNO</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5453"></a>Name</h5>
<dd>
<p><a name="marker-329057"></a>errno - global error variable</p>

<dt>
<h5><a name="idx-5454"></a>Synopsis</h5>
<dd>
<p><pre>int errno;</pre></p>

<dt>
<h5><a name="idx-5455"></a>Description</h5>
<dd>
<p>The global error variable errno is used by several libraries - including Socklib - to provide diagnostics for errors when making calls. Typically, when an error occurs the call returns -1, and errno is set to a value that indicates the reason for the error. Possible values errno may take are:</p>
<dl>
<dd>
<table>
<tr>
<th align="left" valign="top">Value
<th align="left" valign="top">Name
<th align="left" valign="top">Meaning
<tr>
<td align="left" valign="top">0
<td align="left" valign="top">
<td align="left" valign="top">Error 0
<tr>
<td align="left" valign="top">1
<td align="left" valign="top">EPERM
<td align="left" valign="top">Not owner
<tr>
<td align="left" valign="top">2
<td align="left" valign="top">ENOENT
<td align="left" valign="top">No such file or directory
<tr>
<td align="left" valign="top">3
<td align="left" valign="top">ESRCH
<td align="left" valign="top">No such process
<tr>
<td align="left" valign="top">4
<td align="left" valign="top">EINTR
<td align="left" valign="top">Interrupted system call
<tr>
<td align="left" valign="top">5
<td align="left" valign="top">EIO
<td align="left" valign="top">I/O error
<tr>
<td align="left" valign="top">6
<td align="left" valign="top">ENXIO
<td align="left" valign="top">No such device or address
<tr>
<td align="left" valign="top">7
<td align="left" valign="top">E2BIG
<td align="left" valign="top">Arg list too long
<tr>
<td align="left" valign="top">8
<td align="left" valign="top">ENOEXEC
<td align="left" valign="top">Exec format error
<tr>
<td align="left" valign="top">9
<td align="left" valign="top">EBADF
<td align="left" valign="top">Bad file number
<tr>
<td align="left" valign="top">10
<td align="left" valign="top">ECHILD
<td align="left" valign="top">No children
<tr>
<td align="left" valign="top">11
<td align="left" valign="top">EAGAIN
<td align="left" valign="top">Resource temporarily unavailable
<tr>
<td align="left" valign="top">12
<td align="left" valign="top">ENOMEM
<td align="left" valign="top">Not enough memory
<tr>
<td align="left" valign="top">13
<td align="left" valign="top">EACCES
<td align="left" valign="top">Permission denied
<tr>
<td align="left" valign="top">14
<td align="left" valign="top">EFAULT
<td align="left" valign="top">Bad address
<tr>
<td align="left" valign="top">15
<td align="left" valign="top">ENOTBLK
<td align="left" valign="top">Block device required
<tr>
<td align="left" valign="top">16
<td align="left" valign="top">EBUSY
<td align="left" valign="top">Device busy
<tr>
<td align="left" valign="top">17
<td align="left" valign="top">EEXIST
<td align="left" valign="top">File exists
<tr>
<td align="left" valign="top">18
<td align="left" valign="top">EXDEV
<td align="left" valign="top">Cross-device link
<tr>
<td align="left" valign="top">19
<td align="left" valign="top">ENODEV
<td align="left" valign="top">No such device
<tr>
<td align="left" valign="top">20
<td align="left" valign="top">ENOTDIR
<td align="left" valign="top">Not a directory
<tr>
<td align="left" valign="top">21
<td align="left" valign="top">EISDIR
<td align="left" valign="top">Is a directory
<tr>
<td align="left" valign="top">22
<td align="left" valign="top">EINVAL
<td align="left" valign="top">Invalid argument
<tr>
<td align="left" valign="top">23
<td align="left" valign="top">ENFILE
<td align="left" valign="top">File table overflow
<tr>
<td align="left" valign="top">24
<td align="left" valign="top">EMFILE
<td align="left" valign="top">Too many open files
<tr>
<td align="left" valign="top">25
<td align="left" valign="top">ENOTTY
<td align="left" valign="top">Inappropriate I/O control operation
<tr>
<td align="left" valign="top">26
<td align="left" valign="top">ETXTBSY
<td align="left" valign="top">Text file busy
<tr>
<td align="left" valign="top">27
<td align="left" valign="top">EFBIG
<td align="left" valign="top">File too large
<tr>
<td align="left" valign="top">28
<td align="left" valign="top">ENOSPC
<td align="left" valign="top">No space left on device
<tr>
<td align="left" valign="top">29
<td align="left" valign="top">ESPIPE
<td align="left" valign="top">Illegal seek
<tr>
<td align="left" valign="top">30
<td align="left" valign="top">EROFS
<td align="left" valign="top">Read-only file system
<tr>
<td align="left" valign="top">31
<td align="left" valign="top">EMLINK
<td align="left" valign="top">Too many links
<tr>
<td align="left" valign="top">32
<td align="left" valign="top">EPIPE
<td align="left" valign="top">Broken pipe
<tr>
<td align="left" valign="top">33
<td align="left" valign="top">EDOM
<td align="left" valign="top">Argument value error
<tr>
<td align="left" valign="top">34
<td align="left" valign="top">ERANGE
<td align="left" valign="top">Result out of range
<tr>
<td align="left" valign="top">35
<td align="left" valign="top">EWOULDBLOCK
<td align="left" valign="top">Operation would block
<tr>
<td align="left" valign="top">36
<td align="left" valign="top">EINPROGRESS
<td align="left" valign="top">Operation now in progress
<tr>
<td align="left" valign="top">37
<td align="left" valign="top">EALREADY
<td align="left" valign="top">Operation already in progress
<tr>
<td align="left" valign="top">38
<td align="left" valign="top">ENOTSOCK
<td align="left" valign="top">Socket operation on non-socket
<tr>
<td align="left" valign="top">39
<td align="left" valign="top">EDESTADDRREQ
<td align="left" valign="top">Destination address required
<tr>
<td align="left" valign="top">40
<td align="left" valign="top">EMSGSIZE
<td align="left" valign="top">Message too long
<tr>
<td align="left" valign="top">41
<td align="left" valign="top">EPROTOTYPE
<td align="left" valign="top">Protocol wrong type for socket
<tr>
<td align="left" valign="top">42
<td align="left" valign="top">ENOPROTOOPT
<td align="left" valign="top">Option not supported by protocol
<tr>
<td align="left" valign="top">43
<td align="left" valign="top">EPROTONOSUPPORT
<td align="left" valign="top">Protocol not supported
<tr>
<td align="left" valign="top">44
<td align="left" valign="top">ESOCKTNOSUPPORT
<td align="left" valign="top">Socket type not supported
<tr>
<td align="left" valign="top">45
<td align="left" valign="top">EOPNOTSUPP
<td align="left" valign="top">Operation not supported on socket
<tr>
<td align="left" valign="top">46
<td align="left" valign="top">EPFNOSUPPORT
<td align="left" valign="top">Protocol family not supported
<tr>
<td align="left" valign="top">47
<td align="left" valign="top">EAFNOSUPPORT
<td align="left" valign="top">Address family not supported by protocol family
<tr>
<td align="left" valign="top">48
<td align="left" valign="top">EADDRINUSE
<td align="left" valign="top">Address already in use
<tr>
<td align="left" valign="top">49
<td align="left" valign="top">EADDRNOTAVAIL
<td align="left" valign="top">Can't assign requested address
<tr>
<td align="left" valign="top">50
<td align="left" valign="top">ENETDOWN
<td align="left" valign="top">Network is down
<tr>
<td align="left" valign="top">51
<td align="left" valign="top">ENETUNREACH
<td align="left" valign="top">Network is unreachable
<tr>
<td align="left" valign="top">52
<td align="left" valign="top">ENETRESET
<td align="left" valign="top">Network dropped connection on reset
<tr>
<td align="left" valign="top">53
<td align="left" valign="top">ECONNABORTED
<td align="left" valign="top">Software caused connection abort
<tr>
<td align="left" valign="top">54
<td align="left" valign="top">ECONNRESET
<td align="left" valign="top">Connection reset by peer
<tr>
<td align="left" valign="top">55
<td align="left" valign="top">ENOBUFS
<td align="left" valign="top">No buffer space available
<tr>
<td align="left" valign="top">56
<td align="left" valign="top">EISCONN
<td align="left" valign="top">Socket is already connected
<tr>
<td align="left" valign="top">57
<td align="left" valign="top">ENOTCONN
<td align="left" valign="top">Socket is not connected
<tr>
<td align="left" valign="top">58
<td align="left" valign="top">ESHUTDOWN
<td align="left" valign="top">Can't send after socket shutdown
<tr>
<td align="left" valign="top">59
<td align="left" valign="top">ETOOMANYREFS
<td align="left" valign="top">Too many references: can't splice
<tr>
<td align="left" valign="top">60
<td align="left" valign="top">ETIMEDOUT
<td align="left" valign="top">Connection timed out
<tr>
<td align="left" valign="top">61
<td align="left" valign="top">EREFUSED
<td align="left" valign="top">Connection refused
<tr>
<td align="left" valign="top">62
<td align="left" valign="top">ELOOP
<td align="left" valign="top">Too many levels of symbolic links
<tr>
<td align="left" valign="top">63
<td align="left" valign="top">ENAMETOOLONG
<td align="left" valign="top">File name too long
<tr>
<td align="left" valign="top">64
<td align="left" valign="top">EHOSTDOWN
<td align="left" valign="top">Host is down
<tr>
<td align="left" valign="top">65
<td align="left" valign="top">EHOSTUNREACH
<td align="left" valign="top">Host is unreachable
<tr>
<td align="left" valign="top">66
<td align="left" valign="top">ENOTEMPTY
<td align="left" valign="top">Directory not empty
<tr>
<td align="left" valign="top">67
<td align="left" valign="top">EPROCLIM
<td align="left" valign="top">Too many processes
<tr>
<td align="left" valign="top">68
<td align="left" valign="top">EUSERS
<td align="left" valign="top">Too many users
<tr>
<td align="left" valign="top">69
<td align="left" valign="top">EDQUOT
<td align="left" valign="top">Disc quota exceeded
<tr>
<td align="left" valign="top">70
<td align="left" valign="top">ESTALE
<td align="left" valign="top">Stale NFS file handle
<tr>
<td align="left" valign="top">71
<td align="left" valign="top">EREMOTE
<td align="left" valign="top">Too many levels of remote in path
<tr>
<td align="left" valign="top">72
<td align="left" valign="top">ENOSTR
<td align="left" valign="top">Not a stream device
<tr>
<td align="left" valign="top">73
<td align="left" valign="top">ETIME
<td align="left" valign="top">Timer expired
<tr>
<td align="left" valign="top">74
<td align="left" valign="top">ENOSR
<td align="left" valign="top">Out of stream resources
<tr>
<td align="left" valign="top">75
<td align="left" valign="top">ENOMSG
<td align="left" valign="top">No message of desired type
<tr>
<td align="left" valign="top">76
<td align="left" valign="top">EBADMSG
<td align="left" valign="top">Not a data message
<tr>
<td align="left" valign="top">77
<td align="left" valign="top">EIDRM
<td align="left" valign="top">Identifier removed
<tr>
<td align="left" valign="top">78
<td align="left" valign="top">EDEADLK
<td align="left" valign="top">Deadlock situation detected/avoided
<tr>
<td align="left" valign="top">79
<td align="left" valign="top">ENOLCK
<td align="left" valign="top">No record locks available
<tr>
<td align="left" valign="top">80
<td align="left" valign="top">ENOMSG
<td align="left" valign="top">No suitable message on queue
<tr>
<td align="left" valign="top">81
<td align="left" valign="top">EIDRM
<td align="left" valign="top">Identifier removed from system
<tr>
<td align="left" valign="top">82
<td align="left" valign="top">ELIBVER
<td align="left" valign="top">Wrong version of shared library
<tr>
<td align="left" valign="top">83
<td align="left" valign="top">ELIBACC
<td align="left" valign="top">Permission denied (shared library)
<tr>
<td align="left" valign="top">84
<td align="left" valign="top">ELIBLIM
<td align="left" valign="top">Shared libraries nested too deeply
<tr>
<td align="left" valign="top">85
<td align="left" valign="top">ELIBNOENT
<td align="left" valign="top">Shared library file not found
<tr>
<td align="left" valign="top">86
<td align="left" valign="top">ELIBNOEXEC
<td align="left" valign="top">Shared library exec format error
<tr>
<td align="left" valign="top">87
<td align="left" valign="top">ENOSYS
<td align="left" valign="top">Function not implemented
</table>
</dl>
<p>For details of the errors individual calls may return, see their documentation.</p>

<dt>
<h5><a name="idx-5456"></a>See also</h5>
<dd>
<p><A HREF="#90429">_INET_ERROR</a>, <A HREF="#64687">XPERROR</a></p>

<dt>
<h5><a name="idx-5457"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329073"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="73224"></a>FILESTAT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5458"></a>Name</h5>
<dd>
<p>filestat - get <a name="marker-329077"></a>file status</p>

<dt>
<h5><a name="idx-5459"></a>Synopsis</h5>
<dd>
<p><pre>int filestat(path, type)
char *path;
char *type;</pre></p>

<dt>
<h5><a name="idx-5460"></a>Description</h5>
<dd>
<p>Filestat obtains information about the file path. Read or write permission of the named file is not required, but all directories listed in the path name leading to the file must be reachable. The file is searched for using the path held in the RISC OS system variable File$Path. If path contains wildcards, only the first file matching the wildcard specification is read.</p>
<p>On exit, type contains the file's object type:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">0
<td align="left" valign="top">Not found
<tr>
<td align="left" valign="top">1
<td align="left" valign="top">File found
<tr>
<td align="left" valign="top">2
<td align="left" valign="top">Directory found
<tr>
<td align="left" valign="top">3
<td align="left" valign="top">Image file found (ie both file and directory)
</table>
</dl>

<dt>
<h5><a name="idx-5461"></a>Return value</h5>
<dd>
<p>Upon successful completion the length of the file is returned. Otherwise, a value of -1 is returned and errno is set to indicate the error.</p>

<dt>
<h5><a name="idx-5462"></a>Errors</h5>
<dd>
<p>Filestat will fail if:</p>
<dl>
<dd>
<p>[ENOENT] The named file does not exist</p>
</dl>

<dt>
<h5><a name="idx-5463"></a>See also</h5>
<dd>
<p><A HREF="#89782">ACCESS</a></p>

<dt>
<h5><a name="idx-5464"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329079"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="55858"></a>FLUSHINPUT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5465"></a>Name</h5>
<dd>
<p>flushinput - flushes the input <a name="marker-329083"></a>buffer</p>

<dt>
<h5><a name="idx-5466"></a>Synopsis</h5>
<dd>
<p><pre>void flushinput()</pre></p>

<dt>
<h5><a name="idx-5467"></a>Description</h5>
<dd>
<p>Flushinput flushes the current RISC OS input buffer. The contents of the buffer are discarded.</p>

<dt>
<h5><a name="idx-5468"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329091"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="46060"></a>FSTAT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5469"></a>Name</h5>
<dd>
<p>fstat - get <a name="marker-329097"></a>socket status</p>

<dt>
<h5><a name="idx-5470"></a>Synopsis</h5>
<dd>
<p><pre>int fstat(sd, buf)
int sd;
char *buf;</pre></p>

<dt>
<h5><a name="idx-5471"></a>Description</h5>
<dd>
<p>Fstat is a synonym for socketstat; see <A HREF="#11589">SOCKETSTAT</a>. The call is provided mainly so that you do not need to rename fstat calls in code that you are porting.</p>

<dt>
<h5><a name="idx-5472"></a>See also</h5>
<dd>
<p><A HREF="#11589">SOCKETSTAT</a></p>

<dt>
<h5><a name="idx-5473"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329100"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="81046"></a>GETDTABLESIZE</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5474"></a>Name</h5>
<dd>
<p>getdtablesize - get <a name="marker-329104"></a>descriptor table size</p>

<dt>
<h5><a name="idx-5475"></a>Synopsis</h5>
<dd>
<p><pre>int getdtablesize()</pre></p>

<dt>
<h5><a name="idx-5476"></a>Description</h5>
<dd>
<p>Getdtablesize is a synonym for getstablesize; see <A HREF="#32962">GETSTABLESIZE</a>. The call is provided mainly so that you do not need to rename getdtablesize calls in code that you are porting.</p>

<dt>
<h5><a name="idx-5477"></a>See also</h5>
<dd>
<p><A HREF="#32962">GETSTABLESIZE</a></p>

<dt>
<h5><a name="idx-5478"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329106"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="14661"></a>GETEGID</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5479"></a>Name</h5>
<dd>
<p>getegid - get <a name="marker-329118"></a>group identity</p>

<dt>
<h5><a name="idx-5480"></a>Synopsis</h5>
<dd>
<p><pre>int getegid()</pre></p>

<dt>
<h5><a name="idx-5481"></a>Description</h5>
<dd>
<p>Getegid returns the effective group ID of the current process.</p>
<p>As RISC OS has no concept of group IDs, the Unixlib version of this call always returns 9999. The call is provided mainly so that you do not need to remove calls to getegid from code that you are porting.</p>

<dt>
<h5><a name="idx-5482"></a>See also</h5>
<dd>
<p><A HREF="#67596">GETUID</a></p>

<dt>
<h5><a name="idx-5483"></a>Exported by</h5>
<dd>
<p>Unixlib</p>
</dl>
<dt>
<hr><h2 align="right"><a name="93158"></a>GETGROUPS</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5484"></a>Name</h5>
<dd>
<p>getgroups - get group access list</p>

<dt>
<h5><a name="idx-5485"></a>Synopsis</h5>
<dd>
<p><pre>int getgroups(gidsetlen, gidset)
int gidsetlen, *gidset;</pre></p>

<dt>
<h5><a name="idx-5486"></a>Description</h5>
<dd>
<p>Getgroups gets the current group access list of the user process and stores it in the array gidset. The parameter gidsetlen indicates the number of entries that may be placed in gidset. Getgroups returns the actual number of groups returned in gidset. No more than NGROUPS, as defined in "sys/param.h", will ever be returned.</p>
<p>Note that the gidset array should be of type <tt>gid_t</tt>, but remains integer for compatibility with earlier BSD Unix systems.</p>
<p>As RISC OS has no concept of group access lists, the Unixlib version of this call always places the single group ID 9999 in the array gidset, and returns 1. The call is provided mainly so that you do not need to remove calls to getgroups from code that you are porting.</p>

<dt>
<h5><a name="idx-5487"></a>Return value</h5>
<dd>
<p>This call always returns 1, which is the number of groups in the group set.</p>

<dt>
<h5><a name="idx-5488"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329131"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="57988"></a>GETHOSTBYNAME</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5489"></a>Name</h5>
<dd>
<p><a name="marker-329147"></a><a name="marker-329143"></a>gethostbyname, gethostbyaddr, gethostent, sethostent, endhostent - get network host entry</p>

<dt>
<h5><a name="idx-5490"></a>Synopsis</h5>
<dd>
<p><pre>void sethostent(stayopen)
int stayopen;
void endhostent()
#include "netdb.h"
struct hostent *gethostbyname(name)
char *name;
struct hostent *gethostbyaddr(addr, len, type)
char *addr;
int len, type;
struct hostent *gethostent()</pre></p>

<dt>
<h5><a name="idx-5491"></a>Description</h5>
<dd>
<p><i>Gethostbyname</i> and <i>gethostbyaddr</i> each return a pointer to an object describing an Internet host referenced by name or by address, respectively. The calls query entries in a local data base file, setup as <a name="marker-314727"></a><i>InetDBase:hosts</i><a name="marker-314728"></a>. The information is returned in the following structure:</p>
<dl>
<dd>
<pre>struct hostent
{
  char  *h_name;
  char **h_aliases;
  int    h_addrtype;
  int    h_length;
  char **h_addr_list;
};
#define h_addr h_addr_list[0]</pre>
</dl>
<p>The members of this structure are:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">h_name
<td align="left" valign="top">Official name of the host.
<tr>
<td align="left" valign="top">h_aliases
<td align="left" valign="top">A zero terminated array of alternate names for the host.
<tr>
<td align="left" valign="top">h_addrtype
<td align="left" valign="top">The type of address being returned; currently always AF_INET.
<tr>
<td align="left" valign="top">h_length
<td align="left" valign="top">The length, in bytes, of the address.
<tr>
<td align="left" valign="top">h_addr_list
<td align="left" valign="top">A zero terminated array of network addresses for the host. Host addresses are returned in network byte order.
<tr>
<td align="left" valign="top">h_addr
<td align="left" valign="top">The first address in h_addr_list.
</table>
</dl>
<p><i>Gethostent</i> reads the next line of <i>InetDBase:hosts</i><a name="marker-314738"></a>, opening the file if necessary.</p>
<p><i>Sethostent</i> opens and rewinds the file. If the <i>stayopen</i> argument is non-zero, the hosts data base will not be closed after each call to <i>gethostbyname</i> or <i>gethostbyaddr</i>.</p>
<p><i>Endhostent</i> closes the file.</p>
<p>The _host_stayopen symbol is exported for internal use only. You must not use it in your own code.</p>

<dt>
<h5><a name="idx-5492"></a>Return value</h5>
<dd>
<p>Error return status from <i>gethostbyname</i> and <i>gethostbyaddr</i> is indicated by return of a null pointer.</p>

<dt>
<h5><a name="idx-5493"></a>Bugs</h5>
<dd>
<p>All information is contained in a static area so it must be copied if it is to be saved.</p>

<dt>
<h5><a name="idx-5494"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-329149"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="61210"></a>GETHOSTNAME</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5495"></a>Name</h5>
<dd>
<p>gethostname - get name of current host</p>

<dt>
<h5><a name="idx-5496"></a>Synopsis</h5>
<dd>
<p><pre>int gethostname(name, namelen)
char *name;
int namelen;</pre></p>

<dt>
<h5><a name="idx-5497"></a>Description</h5>
<dd>
<p><i>Gethostname</i> returns the standard Internet host name for the current processor, as set in the system variable <a name="marker-315962"></a><i>Inet$HostName</i>. The parameter <i>namelen</i> specifies the size of the <i>name</i> array. The returned name is null-terminated unless insufficient space is provided.</p>
<p>If the system variable <i>Inet$HostName</i> is not set, or if it is set to the null string, then the call attempts to set it to 'ARM_NoName', and - whether or not successful - this is also the name returned in the <i>name</i> array.</p>

<dt>
<h5><a name="idx-5498"></a>Return value</h5>
<dd>
<p>A zero value is always returned.</p>

<dt>
<h5><a name="idx-5499"></a>Bugs</h5>
<dd>
<p>Host names are limited to MAXHOSTNAMELEN (from <i>"sys/param.h"</i>) characters, currently 64.</p>
<p>All information is contained in a static area so it must be copied if it is to be saved.</p>

<dt>
<h5><a name="idx-5500"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329170"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="42987"></a>GETLOGIN</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5501"></a>Name</h5>
<dd>
<p>getlogin - get <a name="marker-329193"></a>login name</p>

<dt>
<h5><a name="idx-5502"></a>Synopsis</h5>
<dd>
<p><pre>char *getlogin()</pre></p>

<dt>
<h5><a name="idx-5503"></a>Description</h5>
<dd>
<p>Getlogin is a synonym for getvarusername; see <A HREF="#59461">GETVAR</a>. The call is provided mainly so that you do not need to rename getlogin calls in code that you are porting.</p>

<dt>
<h5><a name="idx-5504"></a>See also</h5>
<dd>
<p>getvarusername (<A HREF="#59461">GETVAR</a>)</p>

<dt>
<h5><a name="idx-5505"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329198"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="83249"></a>GETNETENT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5506"></a>Name</h5>
<dd>
<p><a name="marker-329237"></a><a name="marker-329227"></a>getnetent, getnetbyaddr, getnetbyname, setnetent, endnetent - get network entry</p>

<dt>
<h5><a name="idx-5507"></a>Synopsis</h5>
<dd>
<p><pre>void setnetent(stayopen)
int stayopen;
void endnetent()
#include "netdb.h"
struct netent *getnetent()
struct netent *getnetbyname(name)
char *name;
struct netent *getnetbyaddr(net, type)
int net, type;</pre></p>

<dt>
<h5><a name="idx-5508"></a>Description</h5>
<dd>
<p><i>Getnetent</i>, <i>getnetbyname</i>, and <i>getnetbyaddr</i> each return a pointer to an object with the following structure containing the broken-out fields of a line in the <a name="marker-314906"></a>network data base, <i>InetDBase:networks</i>.</p>
<dl>
<dd>
<pre>struct netent
{
  char           *n_name;
  char          **n_aliases;
  int             n_addrtype;
  unsigned long   n_net;
};</pre>
</dl>
<p>The members of this structure are:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">n_name
<td align="left" valign="top">The official name of the network.
<tr>
<td align="left" valign="top">n_aliases
<td align="left" valign="top">A zero terminated list of alternate names for the network.
<tr>
<td align="left" valign="top">n_addrtype
<td align="left" valign="top">The type of the network number returned; currently only AF_INET.
<tr>
<td align="left" valign="top">n_net
<td align="left" valign="top">The network number. Network numbers are returned in machine <a name="marker-327327"></a>byte order.
</table>
</dl>
<p><i>Getnetent</i> reads the next line of <i>InetDBase:networks</i>, opening the file if necessary.</p>
<p><i>Setnetent</i> opens and rewinds the file. If the <i>stayopen</i> argument is non-zero, the <a name="marker-314918"></a>net data base will not be closed after each call to <i>getnetbyname</i> or <i>getnetbyaddr</i>.</p>
<p><i>Endnetent</i> closes the file.</p>
<p><i>Getnetbyname</i> and <i>getnetbyaddr</i> sequentially search from the beginning of the file until a matching net name or <a name="marker-328172"></a>net address and type is found, or until EOF is encountered. Network numbers are supplied in <a name="marker-328173"></a>host order.</p>
<p>The _net_stayopen symbol is exported for internal use only. You must not use it in your own code.</p>

<dt>
<h5><a name="idx-5509"></a>Return value</h5>
<dd>
<p>A Null pointer (0) is returned on EOF or error.</p>

<dt>
<h5><a name="idx-5510"></a>Bugs</h5>
<dd>
<p>All information is contained in a static area so it must be copied if it is to be saved.</p>

<dt>
<h5><a name="idx-5511"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-329233"></a><a name="marker-329239"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="46888"></a>GETPASS</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5512"></a>Name</h5>
<dd>
<p>getpass - read a <a name="marker-329243"></a>password</p>

<dt>
<h5><a name="idx-5513"></a>Synopsis</h5>
<dd>
<p><pre>char *getpass(prompt)
char *prompt;</pre></p>

<dt>
<h5><a name="idx-5514"></a>Description</h5>
<dd>
<p>Getpass reads a password from the current input stream, after prompting with the null-terminated string prompt and disabling echoing. A pointer is returned to a null-terminated string of at most 8 characters.</p>

<dt>
<h5><a name="idx-5515"></a>Bugs</h5>
<dd>
<p>The return value points to static data whose content is overwritten by each call.</p>

<dt>
<h5><a name="idx-5516"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329245"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="99966"></a>GETPEERNAME</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5517"></a>Name</h5>
<dd>
<p>getpeername - get name of connected <a name="marker-302142"></a>peer</p>

<dt>
<h5><a name="idx-5518"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
#include "sys/types.h"
int getpeername(s, name, namelen)
int s;
struct sockaddr *name;
int *namelen;</pre></p>

<dt>
<h5><a name="idx-5519"></a>Description</h5>
<dd>
<p><i>Getpeername</i> returns the name of the peer connected to socket <i>s</i>. The <i>namelen</i> parameter should be initialized to indicate the amount of space pointed to by <i>name</i>. On return it contains the actual size of the name returned (in bytes). The name is truncated if the buffer provided is too small.</p>

<dt>
<h5><a name="idx-5520"></a>Return value</h5>
<dd>
<p>A 0 is returned if the call succeeds, -1 if it fails.</p>

<dt>
<h5><a name="idx-5521"></a>Errors</h5>
<dd>
<p>The call succeeds unless:</p>
<dl>
<dd>
<p>[<a name="marker-302150"></a>EBADF] The argument <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-302152"></a>ENOTCONN] The socket is not connected.</p>
<p>[<a name="marker-302154"></a>ENOBUFS] Insufficient resources were available in the system to perform the operation.</p>
<p>[<a name="marker-302156"></a>EFAULT] The <i>name</i> parameter was invalid.</p>
</dl>

<dt>
<h5><a name="idx-5522"></a>See also</h5>
<dd>
<p><A HREF="#10536">ACCEPT</a>, <A HREF="#36015">BIND</a>, <A HREF="#85806">SOCKET</a>, <A HREF="#45457">GETSOCKNAME</a></p>

<dt>
<h5><a name="idx-5523"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329251"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="17008"></a>GETPID</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5524"></a>Name</h5>
<dd>
<p>getpid - get <a name="marker-329257"></a>process identification</p>

<dt>
<h5><a name="idx-5525"></a>Synopsis</h5>
<dd>
<p><pre>int getpid()</pre></p>

<dt>
<h5><a name="idx-5526"></a>Description</h5>
<dd>
<p>Getpid returns the process ID of the current process. Most often it is used to generate uniquely-named temporary files.</p>
<p>As RISC OS has no concept of process IDs, the Unixlib version of this call always returns 9999. The call is provided mainly so that you do not need to remove calls to getpid from code that you are porting.</p>

<dt>
<h5><a name="idx-5527"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329259"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="36948"></a>GETPROTOENT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5528"></a>Name</h5>
<dd>
<p><a name="marker-329284"></a><a name="marker-329270"></a>getprotoent, getprotobynumber, getprotobyname, setprotoent, endprotoent - get protocol entry</p>

<dt>
<h5><a name="idx-5529"></a>Synopsis</h5>
<dd>
<p><pre>void setprotoent(stayopen)
int stayopen;
void endprotoent()
#include "netdb.h"
struct protoent *getprotoent()
struct protoent *getprotobyname(name)
char *name;
struct protoent *getprotobynumber(proto)
int proto;</pre></p>

<dt>
<h5><a name="idx-5530"></a>Description</h5>
<dd>
<p><i>Getprotoent</i>, <i>getprotobyname</i>, and <i>getprotobynumber</i> each return a pointer to an object with the following structure containing the broken-out fields of a line in the Internet <a name="marker-315110"></a>protocol data base, <i>InetDBase:protocols</i>.</p>
<dl>
<dd>
<pre>struct protoent
{
  char    *p_name;
  char    **p_aliases;
  int     p_proto;
};</pre>
</dl>
<p>The members of this structure are:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">p_name
<td align="left" valign="top">The official name of the protocol.
<tr>
<td align="left" valign="top">p_aliases
<td align="left" valign="top">A zero terminated list of alternate names for the protocol.
<tr>
<td align="left" valign="top"><p>p_proto
<td align="left" valign="top">The protocol number.
</table>
</dl>
<p><i>Getprotoent</i> reads the next line of <i>InetDBase:protocols</i>, opening the file if necessary.</p>
<p><i>Setprotoent</i> opens and rewinds the file. If the <i>stayopen</i> argument is non-zero, the <a name="marker-315121"></a>protocol data base will not be closed after each call to <i>getprotobyname</i>.</p>
<p><i>Endprotoent</i> closes the file.</p>
<p><i>Getprotobyname</i> and <i>getprotobynumber</i> sequentially search from the beginning of the file until a matching protocol name or protocol number is found, or until EOF is encountered.</p>
<p>The _proto_stayopen symbol is exported for internal use only. You must not use it in your own code.</p>

<dt>
<h5><a name="idx-5531"></a>Return value</h5>
<dd>
<p>A Null pointer (0) is returned on EOF or error.</p>

<dt>
<h5><a name="idx-5532"></a>Bugs</h5>
<dd>
<p>All information is contained in a static area so it must be copied if it is to be saved.</p>

<dt>
<h5><a name="idx-5533"></a>See also</h5>
<dd>
<p><A HREF="MODULES.HTML#51065">Protocols</a></p>

<dt>
<h5><a name="idx-5534"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-329276"></a><a name="marker-329560"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="23667"></a>GETPWENT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5535"></a>Name</h5>
<dd>
<p>getpwent, getpwuid, getpwnam, setpwent, endpwent - get <a name="marker-329299"></a>password file entry</p>

<dt>
<h5><a name="idx-5536"></a>Synopsis</h5>
<dd>
<p><pre>void setpwent()
void endpwent()
#include "pwd.h"
struct passwd *getpwuid(uid)
int uid;
struct passwd *getpwnam(name)
char *name;
struct passwd *getpwent()</pre></p>

<dt>
<h5><a name="idx-5537"></a>Description</h5>
<dd>
<p>Getpwent, getpwuid and getpwnam each return a pointer to an object with the following structure.</p>
<dl>
<dd>
<pre>struct passwd
{                        /* see getpwent(3) */
  char    *pw_name;
  char    *pw_passwd;
  union { uid_t _uid; int _pad1; } _uid;
  union { gid_t _gid; int _pad2; } _gid;
  int      pw_quota;
  char    *pw_comment;
  char    *pw_gecos;
  char    *pw_dir;
  char    *pw_shell;
};
#define pw_uid _uid._uid
#define pw_gid _gid._gid</pre>
</dl>
<p>The fields pw_passwd, pw_quota, pw_comment, pw_gecos, pw_dir and pw_shell are unused.</p>
<p>Getpwuid sets pw_name to the <a name="marker-329322"></a>name returned by getvarusername, or to 'root' if none is returned; and it sets <a name="marker-329305"></a>pw_uid to 32767, and <a name="marker-329306"></a>pw_gid to 9999.</p>
<p>Getpwnam sets pw_name to name, pw_uid to 32767, and pw_gid to 9999.</p>
<p>Getpwent does the same as getpwuid the first time it is ever called, and the first time it is called after a call to setpwent or endpwent. It otherwise returns a NULL pointer (0).</p>
<p>Setpwent and endpwent have no effect other than altering the behaviour of getpwent (see above).</p>
<p>These calls are provided mainly so that you do not need to remove them from code that you are porting.</p>

<dt>
<h5><a name="idx-5538"></a>Bugs</h5>
<dd>
<p>All information is contained in a static area so it must be copied if it is to be saved.</p>

<dt>
<h5><a name="idx-5539"></a>See also</h5>
<dd>
<p><A HREF="#42987">GETLOGIN</a>, getvarusername (<A HREF="#59461">GETVAR</a>)</p>

<dt>
<h5><a name="idx-5540"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329301"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="34645"></a>GETSERVENT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5541"></a>Name</h5>
<dd>
<p><a name="marker-329330"></a><a name="marker-329324"></a>getservent, getservbyport, getservbyname, setservent, endservent - get service entry</p>

<dt>
<h5><a name="idx-5542"></a>Synopsis</h5>
<dd>
<p><pre>void setservent(stayopen)
int stayopen;
void endservent()
#include "netdb.h"
struct servent *getservent()
struct servent *getservbyname(name, proto)
char *name, *proto;
struct servent *getservbyport(port, proto)
int port;
char *proto;</pre></p>

<dt>
<h5><a name="idx-5543"></a>Description</h5>
<dd>
<p><i>Getservent</i>, <i>getservbyname</i>, and <i>getservbyport</i> each return a pointer to an object with the following structure containing the broken-out fields of a line in the network <a name="marker-315223"></a>services data base, <i>InetDBase:services</i>.</p>
<dl>
<dd>
<pre>struct servent
{
  char  *s_name;
  char **s_aliases;
  int    s_port;
  char  *s_proto;
};</pre>
</dl>
<p>The members of this structure are:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">s_name
<td align="left" valign="top">The official name of the service.
<tr>
<td align="left" valign="top">s_aliases
<td align="left" valign="top">A zero terminated list of alternate names for the service.
<tr>
<td align="left" valign="top">s_port
<td align="left" valign="top">The port number at which the service resides. Port numbers are returned in network byte order.
<tr>
<td align="left" valign="top">s_proto
<td align="left" valign="top">The name of the protocol to use when contacting the service.
</table>
</dl>
<p><i>Getservent</i> reads the next line of the file, opening the file if necessary.</p>
<p><i>Setservent</i> opens and rewinds the file. If the <i>stayopen</i> argument is non-zero, the <a name="marker-315235"></a>services data base will not be closed after each call to <i>getservbyname</i> or <i>getservbyport</i>.</p>
<p><i>Endservent</i> closes the file.</p>
<p><i>Getservbyname</i> and <i>getservbyport</i> sequentially search from the beginning of the file until a matching protocol name or port number is found, or until EOF is encountered. If a protocol name is also supplied (non-NULL), searches must also match the protocol.</p>
<p>The _serv_stayopen symbol is exported for internal use only. You must not use it in your own code.</p>

<dt>
<h5><a name="idx-5544"></a>Return value</h5>
<dd>
<p>A Null pointer (0) is returned on EOF or error.</p>

<dt>
<h5><a name="idx-5545"></a>Bugs</h5>
<dd>
<p>All information is contained in a static area so it must be copied if it is to be saved.</p>

<dt>
<h5><a name="idx-5546"></a>See also</h5>
<dd>
<p><A HREF="#36948">GETPROTOENT</a></p>

<dt>
<h5><a name="idx-5547"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-329326"></a><a name="marker-329332"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="45457"></a>GETSOCKNAME</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5548"></a>Name</h5>
<dd>
<p>getsockname - get <a name="marker-329345"></a>socket name</p>

<dt>
<h5><a name="idx-5549"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/socket.h"
#include "sys/types.h"
int getsockname(s, name, namelen)
int s;
struct sockaddr *name;
int *namelen;</tt></pre>

<dt>
<h5><a name="idx-5550"></a>Description</h5>
<dd>
<p><i>Getsockname</i> returns the current <i>name</i> for the specified socket. The <i>namelen</i> parameter should be initialized to indicate the amount of space pointed to by <i>name</i>. On return it contains the actual size of the name returned (in bytes).</p>

<dt>
<h5><a name="idx-5551"></a>Return value</h5>
<dd>
<p>A 0 is returned if the call succeeds, -1 if it fails.</p>

<dt>
<h5><a name="idx-5552"></a>Errors</h5>
<dd>
<p>The call succeeds unless:</p>
<dl>
<dd>
<p>[<a name="marker-302169"></a>EBADF] The argument <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-302171"></a>ENOBUFS] Insufficient resources were available in the system to perform the operation.</p>
<p>[<a name="marker-314279"></a>EFAULT] The <i>name</i> parameter was invalid.</p>
</dl>

<dt>
<h5><a name="idx-5553"></a>See also</h5>
<dd>
<p><A HREF="#36015">BIND</a>, <A HREF="#85806">SOCKET</a></p>

<dt>
<h5><a name="idx-5554"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329347"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="91651"></a>GETSOCKOPT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5555"></a>Name</h5>
<dd>
<p>getsockopt, setsockopt - get and set options on <a name="marker-321609"></a>sockets</p>

<dt>
<h5><a name="idx-5556"></a>Synopsis</h5>
<dd>
<p><pre>int getsockopt(s, level, optname, optval, optlen)
int s, level, optname;
void *optval;
int *optlen;
int setsockopt(s, level, optname, optval, optlen)
int s, level, optname;
void *optval;
int optlen;</pre></p>

<dt>
<h5><a name="idx-5557"></a>Description</h5>
<dd>
<p><i>Getsockopt</i> and <i>setsockopt</i> manipulate <i>options</i> associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost 'socket' level.</p>
<p>When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the 'socket' level, <i>level</i> is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, <i>level</i> should be set to the protocol number of TCP (see <A HREF="#36948">GETPROTOENT</a>).</p>
<p>The parameters <i>optval</i> and <i>optlen</i> are used to access option values for <i>setsockopt</i>. For <i>getsockopt</i> they identify a buffer in which the value for the requested option(s) are to be returned. For <i>getsockopt</i>, <i>optlen</i> is a value-result parameter, initially containing the size of the buffer pointed to by <i>optval</i>, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, <i>optval</i> may be supplied as 0.</p>
<p><i>Optname</i> and any specified options are passed uninterpreted to the appropriate protocol module for interpretation. The include file <i>"sys/socket.h"</i> contains definitions for 'socket' level options, described below. Options at other protocol levels vary in format and name.</p>
<p>Most socket-level options take an <i>int</i> parameter for <i>optval</i>. For <i>setsockopt</i>, the parameter should be non-zero to enable a boolean option, or zero if the option is to be disabled. SO_LINGER uses a <i>struct linger</i> parameter, defined in <i>"sys/socket.h"</i>, which specifies the desired state of the option and the linger interval (see below).</p>
<p>The following options are recognized at the socket level. Except as noted, each may be examined with <i>getsockopt</i> and set with <i>setsockopt</i>.</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">SO_REUSEADDR
<td align="left" valign="top">toggle local address reuse
<tr>
<td align="left" valign="top">SO_KEEPALIVE
<td align="left" valign="top">toggle keep connections alive
<tr>
<td align="left" valign="top">SO_DONTROUTE
<td align="left" valign="top">toggle routing bypass for outgoing messages
<tr>
<td align="left" valign="top">SO_LINGER
<td align="left" valign="top">linger on close if data present
<tr>
<td align="left" valign="top">SO_BROADCAST
<td align="left" valign="top">toggle permission to transmit broadcast messages
<tr>
<td align="left" valign="top">SO_OOBINLINE
<td align="left" valign="top">toggle reception of out-of-band data in band
<tr>
<td align="left" valign="top">SO_SNDBUF
<td align="left" valign="top">set buffer size for output
<tr>
<td align="left" valign="top">SO_RCVBUF
<td align="left" valign="top">set buffer size for input
<tr>
<td align="left" valign="top">SO_TYPE
<td align="left" valign="top">get the type of the socket (get only)
<tr>
<td align="left" valign="top">SO_ERROR
<td align="left" valign="top">get and clear error on the socket (get only)
</table>
</dl>
<p>SO_REUSEADDR indicates that the rules used in validating addresses supplied in a <i>bind</i> call should allow reuse of local addresses. SO_KEEPALIVE enables the periodic transmission of messages on a connected socket. Should the connected party fail to respond to these messages, the connection is considered broken and programs using the socket are notified via an <i>Internet_Event/Socket_Broken_Event</i> event, provided they have enabled it (see <A HREF="#68725">The Internet event</a>). SO_DONTROUTE indicates that outgoing messages should bypass the standard routing facilities. Instead, messages are directed to the appropriate network interface according to the network portion of the destination address.</p>
<p>SO_LINGER controls the action taken when unsent messages are queued on socket and a <i>socketclose</i> is performed. If the socket promises reliable delivery of data and SO_LINGER is set, the system will block on the <i>socketclose</i> attempt until it is able to transmit the data or until it decides it is unable to deliver the information (a timeout period, termed the linger interval, is specified in the <i>setsockopt</i> call when SO_LINGER is requested). If SO_LINGER is disabled and a <i>socketclose</i> is issued, the system will process the socketclose in a manner that allows control to return to the caller as quickly as possible.</p>
<p>The option SO_BROADCAST requests permission to send <a name="marker-314420"></a>broadcast datagrams on the socket. With protocols that support out-of-band data, the SO_OOBINLINE option requests that out-of-band data be placed in the normal data input queue as received; it will then be accessible with <i>recv</i> calls without the MSG_OOB flag. SO_SNDBUF and SO_RCVBUF are options to adjust the normal buffer sizes allocated for output and input buffers, respectively. The buffer size may be increased for high-volume connections, or may be decreased to limit the possible backlog of incoming data. The system places an absolute limit on these values. Finally, SO_TYPE and SO_ERROR are options used only with <i>setsockopt</i>. SO_TYPE returns the type of the <a name="marker-314423"></a>socket, such as SOCK_STREAM. SO_ERROR returns any pending error on the <a name="marker-314424"></a>socket and clears the error status. It may be used to check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</p>

<dt>
<h5><a name="idx-5558"></a>Return value</h5>
<dd>
<p>A 0 is returned if the call succeeds, -1 if it fails.</p>

<dt>
<h5><a name="idx-5559"></a>Errors</h5>
<dd>
<p>The call succeeds unless:</p>
<dl>
<dd>
<p>[<a name="marker-314428"></a>EBADF] The argument <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-314430"></a>ENOPROTOOPT] The option is unknown at the level indicated.</p>
<p>[<a name="marker-314432"></a>EFAULT] The address pointed to by <i>optval</i> is invalid. For <i>getsockopt</i>, this error may also be returned if <i>optlen</i> is invalid.</p>
</dl>

<dt>
<h5><a name="idx-5560"></a>See also</h5>
<dd>
<p><A HREF="#97822">IOCTL</a>, <A HREF="#99356">SOCKETIOCTL</a>, <A HREF="#85806">SOCKET</a>, <A HREF="#36948">GETPROTOENT</a></p>

<dt>
<h5><a name="idx-5561"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329362"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="32962"></a>GETSTABLESIZE</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5562"></a>Name</h5>
<dd>
<p>getstablesize - get <a name="marker-329366"></a>descriptor table size</p>

<dt>
<h5><a name="idx-5563"></a>Synopsis</h5>
<dd>
<p><pre>int getstablesize()</pre></p>

<dt>
<h5><a name="idx-5564"></a>Description</h5>
<dd>
<p>The Internet module has a fixed size descriptor table, which is guaranteed to have at least 96 slots. The entries in the descriptor table are numbered with small integers starting at 0. The call getstablesize returns the size of this table.</p>

<dt>
<h5><a name="idx-5565"></a>See also</h5>
<dd>
<p><A HREF="#81046">GETDTABLESIZE</a>, <A HREF="#93405">CLOSE</a>, <A HREF="#77741">SOCKETCLOSE</a>, <A HREF="#44018">SELECT</a></p>

<dt>
<h5><a name="idx-5566"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329368"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="23005"></a>GETTIMEOFDAY</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5567"></a>Name</h5>
<dd>
<p><a name="marker-329377"></a>gettimeofday - get date and time</p>

<dt>
<h5><a name="idx-5568"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/time.h"</pre></p>
<p><pre>int gettimeofday(tp, tzp)
struct timeval *tp;
struct timezone *tzp;</pre></p>

<dt>
<h5><a name="idx-5569"></a>Description</h5>
<dd>
<p>The system's notion of the current Greenwich time and the current time zone is <a name="marker-329416"></a>obtained with the gettimeofday call. The time is expressed in seconds and microseconds since midnight (0 hour), January 1, 1970. If tzp is zero, the time zone information will not be returned or set.</p>
<p>The structures pointed to by tp and tzp are defined in "sys/time.h" as:</p>
<dl>
<dd>
<pre>struct timeval
{
  long tv_sec;   /* seconds since Jan. 1, 1970 */
  long tv_usec;  /* and microseconds */
};</pre>
<pre>struct timezone
{
  int tz_minuteswest;  /* of Greenwich */
  int tz_dsttime;      /* type of dst correction to apply */
};</pre>
</dl>
<p>The <a name="marker-329406"></a>timezone structure indicates the local time zone (measured in minutes of time westward from Greenwich), and a flag that, if nonzero, indicates that <a name="marker-329430"></a>Daylight Saving time applies locally during the appropriate part of the year.</p>

<dt>
<h5><a name="idx-5570"></a>Return value</h5>
<dd>
<p>A zero value is always returned. If the date is unset or out of the representable range, then tv_sec is -1.</p>

<dt>
<h5><a name="idx-5571"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329379"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="67596"></a>GETUID</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5572"></a>Name</h5>
<dd>
<p>getuid, geteuid - get <a name="marker-329439"></a>user identity</p>

<dt>
<h5><a name="idx-5573"></a>Synopsis</h5>
<dd>
<p><pre>int getuid()
int geteuid()</pre></p>

<dt>
<h5><a name="idx-5574"></a>Description</h5>
<dd>
<p>Getuid returns the real user ID of the current process, geteuid the effective user ID.</p>
<p>As RISC OS has no concept of user IDs, the Unixlib version of this call always returns 32767. The call is provided mainly so that you do not need to remove calls to getuid and geteuid from code that you are porting.</p>

<dt>
<h5><a name="idx-5575"></a>See also</h5>
<dd>
<p><A HREF="#14661">GETEGID</a></p>

<dt>
<h5><a name="idx-5576"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329445"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="59461"></a>GETVAR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5577"></a>Name</h5>
<dd>
<p>getvarhostname, getvarusername - get <a name="marker-329454"></a>host and <a name="marker-329178"></a>user names from system variables</p>

<dt>
<h5><a name="idx-5578"></a>Synopsis</h5>
<dd>
<p><pre>char *getvarhostname()
char *getvarusername()</pre></p>

<dt>
<h5><a name="idx-5579"></a>Description</h5>
<dd>
<p><i>Getvarhostname</i> returns the standard Internet host name for the current processor, as set in the system variable <a name="marker-316335"></a><i>Inet$HostName</i>. If the variable is not set, or if it is set to the null string, then the call first attempts to set it to 'ARM_NoName'.</p>
<p><i>Getvarusername</i> returns the current user name, as previously set in the system variable <a name="marker-316337"></a><i>Inet$UserName</i>. If <i>Inet$UserName</i> is not set, or if it is set to the null string, getvarusername returns a NULL pointer (0).</p>
<p>The returned name is null-terminated.</p>

<dt>
<h5><a name="idx-5580"></a>Return value</h5>
<dd>
<p>If the call fails, then a NULL pointer (0) is returned.</p>

<dt>
<h5><a name="idx-5581"></a>Bugs</h5>
<dd>
<p>Host names are limited to MAXHOSTNAMELEN (from <i>"sys/param.h"</i>) characters, currently 64.</p>
<p>The return value points to static data whose content is overwritten by each call.</p>

<dt>
<h5><a name="idx-5582"></a>See also</h5>
<dd>
<p><A HREF="#42987">GETLOGIN</a></p>

<dt>
<h5><a name="idx-5583"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329180"></a><a name="marker-329460"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="76464"></a>GETWD</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5584"></a>Name</h5>
<dd>
<p>getwd - get <a name="marker-329473"></a>current working directory pathname</p>

<dt>
<h5><a name="idx-5585"></a>Synopsis</h5>
<dd>
<p><pre>char *getwd(pathname)
char *pathname;</pre></p>

<dt>
<h5><a name="idx-5586"></a>Description</h5>
<dd>
<p>Getwd copies the pathname of the current working directory to pathname and returns a pointer to the result.</p>

<dt>
<h5><a name="idx-5587"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329478"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="44268"></a>HERROR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5588"></a>Name</h5>
<dd>
<p>herror - obsolete call</p>

<dt>
<h5><a name="idx-5589"></a>Synopsis</h5>
<dd>
<p>--</p>

<dt>
<h5><a name="idx-5590"></a>Description</h5>
<dd>
<p>Herror is now obsolete, and you must not use it in your code. It is exported from Unixlib only to ensure backwards compatibility.</p>

<dt>
<h5><a name="idx-5591"></a>Exported by</h5>
<dd>
<p>Unixlib</p>
</dl>
<dt>
<hr><h2 align="right"><a name="44336"></a>INET</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5592"></a>Name</h5>
<dd>
<p>inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, inet_netof - <a name="marker-317360"></a>Internet address manipulation routines</p>

<dt>
<h5><a name="idx-5593"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/types.h"
u_long inet_addr(cp)
char *cp;
u_long inet_network(cp)
char *cp;
#include "netinet/in.h"
char *inet_ntoa(in)
struct in_addr in;
struct in_addr inet_makeaddr(net, lna)
int net, lna;
int inet_lnaof(in)
struct in_addr in;
int inet_netof(in)
struct in_addr in;</pre></p>

<dt>
<h5><a name="idx-5594"></a>Description</h5>
<dd>
<p>The routines <i>inet_addr</i> and <i>inet_network</i> each interpret character strings representing numbers expressed in the Internet standard '.' notation, returning numbers suitable for use as Internet addresses and Internet network numbers, respectively. The routine <i>inet_ntoa</i> takes an Internet address and returns an ASCII string representing the address in '.' notation. The routine <i>inet_makeaddr</i> takes an Internet network number and a local network address and constructs an Internet address from it. The routines <i>inet_netof</i> and <i>inet_lnaof</i> break apart Internet host addresses, returning the network number and local network address part, respectively.</p>
<p>All Internet address are returned in network order (bytes ordered from left to right). All network numbers and local address parts are returned as machine format integer values.</p>

<dt>
<h5><a name="81781"></a>Internet addresses</h5>
<dd>
<p>Values specified using the '.' notation take one of the following forms:</p>
<dl>
<dd>
a.b.c.d<br>
a.b.c<br>
a.b<br>
a
</dl>
<p>When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the four bytes of an Internet address.</p>
<p>When a three part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right-most two bytes of the network address. This makes the three part address format convenient for specifying Class B network addresses as '128.net.host'.</p>
<p>When a two part address is supplied, the last part is interpreted as a 24-bit quantity and placed in the right-most three bytes of the network address. This makes the two part address format convenient for specifying Class A network addresses as 'net.host'.</p>
<p>When only one part is given, the value is stored directly in the network address without any byte rearrangement.</p>
<p>All numbers supplied as 'parts' in a '.' notation may be decimal, octal, or hexadecimal, as specified in the C language (ie a leading 0x or 0X implies hexadecimal; otherwise, a leading 0 implies octal; otherwise, the number is interpreted as decimal).</p>

<dt>
<h5><a name="idx-5595"></a>Return value</h5>
<dd>
<p>The value -1 is returned by <i>inet_addr</i> and <i>inet_network</i> for malformed requests.</p>

<dt>
<h5><a name="idx-5596"></a>Bugs</h5>
<dd>
<p>The string returned by <i>inet_ntoa</i> resides in a static memory area.</p>

<dt>
<h5><a name="idx-5597"></a>See also</h5>
<dd>
<p><A HREF="#57988">GETHOSTBYNAME</a>, <A HREF="#83249">GETNETENT</a></p>

<dt>
<h5><a name="idx-5598"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-329489"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="90429"></a>_INET_ERROR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5599"></a>Name</h5>
<dd>
<p><a name="marker-329496"></a>_inet_error - global error variable</p>

<dt>
<h5><a name="idx-5600"></a>Synopsis</h5>
<dd>
<p><pre>#include "kernel.h"
_kernel_oserror _inet_error</pre></p>

<dt>
<h5><a name="idx-5601"></a>Description</h5>
<dd>
<p>The global error structure _inet_error is used exclusively by the Socklib library. It contains the most recent error block returned from a call into the Internet module, and is set by the function <i>makecall()</i>.</p>

<dt>
<h5><a name="idx-5602"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329498"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="97822"></a>IOCTL</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5603"></a>Name</h5>
<dd>
<p>ioctl - <a name="marker-329509"></a>control device</p>

<dt>
<h5><a name="idx-5604"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/ioctl.h"
int ioctl(d, request, argp)
int d;
int request;
void *argp;</pre></p>

<dt>
<h5><a name="idx-5605"></a>Description</h5>
<dd>
<p>Ioctl is a synonym for socketioctl; see <A HREF="#99356">SOCKETIOCTL</a>. The call is provided mainly so that you do not need to rename ioctl calls in code that you are porting.</p>

<dt>
<h5><a name="idx-5606"></a>See also</h5>
<dd>
<p><A HREF="#99356">SOCKETIOCTL</a></p>

<dt>
<h5><a name="idx-5607"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329515"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="78807"></a>KILLFILE</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5608"></a>Name</h5>
<dd>
<p><a name="marker-329577"></a>killfile - remove directory entry</p>

<dt>
<h5><a name="idx-5609"></a>Synopsis</h5>
<dd>
<p><pre>void killfile(path)
char *path;</pre></p>

<dt>
<h5><a name="idx-5610"></a>Description</h5>
<dd>
<p>Killfile removes the entry for the object path from its directory. The call fails if the object is locked against deletion, or if it is a directory which is not empty, or if it is already open.</p>
<p>No value is returned.</p>
<p>This call is now deprecated, and we recommend you instead use unlink in your code. Killfile is exported from Unixlib only to ensure backwards compatibility.</p>

<dt>
<h5><a name="idx-5611"></a>See also</h5>
<dd>
<p><A HREF="#83611">UNLINK</a></p>

<dt>
<h5><a name="idx-5612"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329583"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="75746"></a>LISTEN</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5613"></a>Name</h5>
<dd>
<p>listen - listen for <a name="marker-302228"></a>connections on a socket</p>

<dt>
<h5><a name="idx-5614"></a>Synopsis</h5>
<dd>
<p><pre>int listen(s, backlog)
int s, backlog;</pre></p>

<dt>
<h5><a name="idx-5615"></a>Description</h5>
<dd>
<p>To accept connections, a socket is first created with <i>socket</i>, a willingness to accept incoming connections and a queue limit for incoming connections are specified with <i>listen</i>, and then the connections are accepted with <i>accept</i>. The <i>listen</i> call applies only to sockets of type SOCK_STREAM.</p>
<p>The <i>backlog</i> parameter defines the maximum length the queue of pending connections may grow to. If a connection request arrives with the queue full the client may receive an error with an indication of <a name="marker-302240"></a>ECONNREFUSED, or, if the underlying protocol supports retransmission, the request may be ignored so that retries may succeed.</p>

<dt>
<h5><a name="idx-5616"></a>Return value</h5>
<dd>
<p>A 0 return value indicates success; -1 indicates an error.</p>

<dt>
<h5><a name="idx-5617"></a>Errors</h5>
<dd>
<p>The call fails if:</p>
<dl>
<dd>
<p>[<a name="marker-302243"></a>EBADF] The argument <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-302245"></a>EOPNOTSUPP] The socket is not of a type that supports the operation <i>listen</i>.</p>
</dl>

<dt>
<h5><a name="idx-5618"></a>Bugs</h5>
<dd>
<p>The <i>backlog</i> is currently limited (silently) to 5 and negative numbers are replaced by 0.</p>
<p>It is not the queue length - this is currently defined by:</p>
<dl>
<dd>
(<i>backlog</i> &times; 3)/2 + 1
</dl>

<dt>
<h5><a name="idx-5619"></a>See also</h5>
<dd>
<p><A HREF="#10536">ACCEPT</a>, <A HREF="#11499">CONNECT</a>, <A HREF="#85806">SOCKET</a></p>

<dt>
<h5><a name="idx-5620"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329601"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="18572"></a>LSEEK</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5621"></a>Name</h5>
<dd>
<p>lseek - move read/write pointer</p>

<dt>
<h5><a name="idx-5622"></a>Synopsis</h5>
<dd>
<p><pre>long lseek(d, offset, whence)
int d;
long offset;
int whence;</pre></p>

<dt>
<h5><a name="idx-5623"></a>Description</h5>
<dd>
<p>Lseek sets the file pointer of d. Since you cannot seek on sockets, the Unixlib version of lseek always fails and the file pointer remains unchanged.</p>

<dt>
<h5><a name="idx-5624"></a>Return value</h5>
<dd>
<p>A value of -1 is always returned.</p>

<dt>
<h5><a name="idx-5625"></a>Errors</h5>
<dd>
<p>Errno is always set to indicate the error.</p>
<dl>
<dd>
<p>[ESPIPE] d is associated with a pipe or a socket.</p>
</dl>

<dt>
<h5><a name="idx-5626"></a>Exported by</h5>
<dd>
<p>Unixlib</p>
</dl>
<dt>
<hr><h2 align="right"><a name="48705"></a>_MAKECALL</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5627"></a>Name</h5>
<dd>
<p><a name="marker-329606"></a>_makecall - wrapper for SWI calls</p>

<dt>
<h5><a name="idx-5628"></a>Synopsis</h5>
<dd>
<p><pre>#include kernel.h
int _makecall(swinum, in, out)
int swinum
_kernel_swi_regs *in, *out</pre></p>

<dt>
<h5><a name="idx-5629"></a>Description</h5>
<dd>
<p>Makecall provides a wrapper for calling SWIs, and is used by Socklib for all Socket_... SWIs calls it makes. The first thing makecall does is to issue the SWI. Its subsequent action depends on whether or not the SWI returns an error:</p>
<ul>
<li>If the SWI does not return an error, the global error variable errno is set to zero, and the return value of makecall is the value that was in R0 on exit from the SWI.
<li>If the SWI returns an error, makecall copies the returned error block into the global error structure _inet_error. It then sets errno from the SWI's returned error number, converting standard Internet errors (ie those returned by the SWI in the range &amp;20E00 - &amp;20E7F) to the values used in C by subtracting &amp;20E00. If - after that - the value of errno is still greater than <a name="marker-329612"></a>EREMOTE, makecall then sets errno to <a name="marker-329613"></a>ESRCH. Finally, makecall returns a value of -1.
</ul>

<dt>
<h5><a name="idx-5630"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329608"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="71667"></a>NAMISIPADR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5631"></a>Name</h5>
<dd>
<p><a name="marker-329620"></a><a name="marker-329614"></a>namisipadr - get network host entry</p>

<dt>
<h5><a name="idx-5632"></a>Synopsis</h5>
<dd>
<p><pre>#include "netdb.h"
struct hostent *namisipadr(name)
char* name</pre></p>

<dt>
<h5><a name="idx-5633"></a>Description</h5>
<dd>
<p><i>Namisipadr</i> takes an Internet address and returns a pointer to an object describing an Internet host. The Internet address is a character string representing numbers expressed in the Internet standard '.' notation; for more details see <A HREF="#81781">Internet addresses</a>. The information is returned in the following structure:</p>
<dl>
<dd>
<pre>struct hostent
{
  char  *h_name;
  char **h_aliases;
  int    h_addrtype;
  int    h_length;
  char **h_addr_list;
};
#define h_addr h_addr_list[0]</pre>
</dl>
<p>The members of this structure are:</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">h_name
<td align="left" valign="top">Official name of the host.
<tr>
<td align="left" valign="top">h_aliases
<td align="left" valign="top">A zero terminated array of alternate names for the host.
<tr>
<td align="left" valign="top">h_addrtype
<td align="left" valign="top">The type of address being returned; currently always AF_INET.
<tr>
<td align="left" valign="top">h_length
<td align="left" valign="top">The length, in bytes, of the address.
<tr>
<td align="left" valign="top">h_addr_list
<td align="left" valign="top">A zero terminated array of network addresses for the host. Host addresses are returned in network byte order.
<tr>
<td align="left" valign="top">h_addr
<td align="left" valign="top">The first address in h_addr_list.
</table>
</dl>

<dt>
<h5><a name="idx-5634"></a>Return value</h5>
<dd>
<p>Error return status from <i>namisipadr</i> is indicated by return of a null pointer.</p>

<dt>
<h5><a name="idx-5635"></a>Bugs</h5>
<dd>
<p>All information is contained in a static area so it must be copied if it is to be saved.</p>

<dt>
<h5><a name="idx-5636"></a>See also</h5>
<dd>
<p>inet_addr (<A HREF="#44336">INET</a>), <A HREF="#57988">GETHOSTBYNAME</a></p>

<dt>
<h5><a name="idx-5637"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-329616"></a><a name="marker-329625"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="30442"></a>OSREADC</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5638"></a>Name</h5>
<dd>
<p>osreadc - reads a <a name="marker-329629"></a>character from the current input stream</p>

<dt>
<h5><a name="idx-5639"></a>Synopsis</h5>
<dd>
<p><pre>int osreadc()</pre></p>

<dt>
<h5><a name="idx-5640"></a>Description</h5>
<dd>
<p>Osreadc is a veneer to <A HREF="CHARINPUT.HTML#93765">OS_ReadC</a>, which reads a character from the current input stream.</p>

<dt>
<h5><a name="idx-5641"></a>Return value</h5>
<dd>
<p>Osreadc returns the ASCII code of the key pressed, or EOF if Escape was pressed.</p>

<dt>
<h5><a name="idx-5642"></a>See also</h5>
<dd>
<p><A HREF="#92110">XGETS</a></p>

<dt>
<h5><a name="idx-5643"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329632"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="10604"></a>_PWBUF</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5644"></a>Name</h5>
<dd>
<p>_pwbuf - symbol for internal use only</p>

<dt>
<h5><a name="idx-5645"></a>Synopsis</h5>
<dd>
<p>--</p>

<dt>
<h5><a name="idx-5646"></a>Description</h5>
<dd>
<p>The _pwbuf symbol is exported for internal use only. You must not use it in your own code.</p>

<dt>
<h5><a name="idx-5647"></a>Exported by</h5>
<dd>
<p>Unixlib</p>
</dl>
<dt>
<hr><h2 align="right"><a name="77996"></a>READ</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5648"></a>Name</h5>
<dd>
<p><a name="marker-329636"></a>read, readv - read input</p>

<dt>
<h5><a name="idx-5649"></a>Synopsis</h5>
<dd>
<p><pre>int read(d, buf, nbytes)
int d;
char *buf;
int nbytes;
#include "sys/types.h"
#include "sys/uio.h"
int readv(d, iov, iovcnt)
int cc, d;
struct iovec *iov;
int iovcnt;</pre></p>

<dt>
<h5><a name="idx-5650"></a>Description</h5>
<dd>
<p>Read is a synonym for socketread, and readv a synonym for socketreadv; see <A HREF="#50260">SOCKETREAD</a>. These calls are provided mainly so that you do not need to rename read and readv calls in code that you are porting.</p>

<dt>
<h5><a name="idx-5651"></a>See also</h5>
<dd>
<p>socketread and socketreadv (<A HREF="#50260">SOCKETREAD</a>)</p>

<dt>
<h5><a name="idx-5652"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329650"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="19983"></a>READDIR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5653"></a>Name</h5>
<dd>
<p>readdir - read a <a name="marker-316569"></a>directory</p>

<dt>
<h5><a name="idx-5654"></a>Synopsis</h5>
<dd>
<p><pre>int readdir(path, buf, len, name, offset)
char *path, *buf;
int len, name, offset;</pre></p>

<dt>
<h5><a name="idx-5655"></a>Description</h5>
<dd>
<p>Readdir reads an entry from the directory path which match the wildcard name name; it is returned in the buffer buf (which is of length len). The offset gives the directory entry from which to start searching; it should be zero to start searching from the start of the directory.</p>
<p>If path (which may contain wildcards) is a null string, then the currently-selected directory is read. If name is a null string then '*' is used, and all files will be matched.</p>

<dt>
<h5><a name="idx-5656"></a>Return value</h5>
<dd>
<p>This call returns the offset from which you should continue searching to read more entries; or -1 if no entry was read, or there are no more entries after the one read by this call.</p>

<dt>
<h5><a name="idx-5657"></a>Bugs</h5>
<dd>
<p>This implementation of readdir is <b>not</b> a direct replacement or emulation of the Unix readdir function. You should bear this especially in mind if you are porting software.</p>

<dt>
<h5><a name="idx-5658"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329656"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="32246"></a>RECV</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5659"></a>Name</h5>
<dd>
<p>recv, recvfrom, recvmsg - <a name="marker-302252"></a>receive a message from a socket</p>

<dt>
<h5><a name="idx-5660"></a>Synopsis</h5>
<dd>
<p><pre>int recv(s, buf, len, flags)
int s;
char *buf;
int len, flags;
#include "sys/socket.h"
#include "sys/types.h"
int recvfrom(s, buf, len, flags, from, fromlen)
int s;
char *buf;
int len, flags;
struct sockaddr *from;
int *fromlen;
#include "sys/uio.h"
int recvmsg(s, msg, flags)
int s;
struct msghdr *msg;
int flags;</pre></p>

<dt>
<h5><a name="idx-5661"></a>Description</h5>
<dd>
<p><i>Recv</i>, <i>recvfrom</i>, and <i>recvmsg</i> are used to receive messages from a socket.</p>
<p>The <i>recv</i> call is normally used only on a <i>connected</i> socket, while <i>recvfrom</i> and <i>recvmsg</i> may be used to receive data on a socket whether it is in a connected state or not.</p>
<p>If <i>from</i> is non-zero, the source address of the message is filled in. <i>Fromlen</i> is a value-result parameter, initialized to the size of the buffer associated with <i>from</i>, and modified on return to indicate the actual size of the address stored there. The length of the message is returned in <i>cc</i>. If a message is too long to fit in the supplied buffer, excess bytes may be discarded depending on the type of socket the message is received from (see <i>socket</i> on <A HREF="#85806">SOCKET</a>).</p>
<p>If no messages are available at the socket, the receive call waits for a message to arrive, unless the socket is non-blocking (see <i>socketioctl</i> on <A HREF="#99356">SOCKETIOCTL</a>) in which case a <i>cc</i> of -1 is returned with the external variable errno set to EWOULDBLOCK.</p>
<p>The <i>select</i> call may be used to determine when more data arrives.</p>
<p>The <i>flags</i> argument to a recv call is formed by or'ing one or more of the values,</p>
<p><pre>#define MSG_OOB 0x1  /* process out-of-band data */
#define MSG_PEEK 0x2  /* peek at incoming message */</pre></p>
<p>The <i>recvmsg</i> call uses a <i>msghdr</i> structure to minimize the number of directly supplied parameters. This structure has the following form, as defined in <i>"sys/socket.h"</i>:</p>
<dl>
<dd>
<pre>struct msghdr
{
  caddr_t       msg_name;          /* optional address */
  int           msg_namelen;       /* size of address */
  struct iovec *msg_iov;           /* scatter/gather array */
  int           msg_iovlen;        /* # elements in msg_iov */
  caddr_t       msg_accrights;     /* access rights sent/received */
  int           msg_accrightslen;
};</pre>
</dl>
<p>Here <i>msg_name</i> and <i>msg_namelen</i> specify the destination address if the socket is unconnected; <i>msg_name</i> may be given as a null pointer if no names are desired or required. The <i>msg_iov</i> and <i>msg_iovlen</i> describe the scatter gather locations, as described in <i>socketread</i> on <A HREF="#50260">SOCKETREAD</a>. A buffer to receive any access rights sent along with the message is specified in <i>msg_accrights</i>, which has length <i>msg_accrightslen</i>. Access rights are currently limited to integer values. If access rights are not being transferred, the <i>msg_accrights</i> field should be set to NULL.</p>

<dt>
<h5><a name="idx-5662"></a>Return value</h5>
<dd>
<p>These calls return the number of bytes received, or -1 if an error occurred.</p>

<dt>
<h5><a name="idx-5663"></a>Errors</h5>
<dd>
<p>The calls fail if:</p>
<dl>
<dd>
<p>[<a name="marker-302272"></a>EBADF] The argument <i>s</i> is an invalid descriptor.</p>
<p>[<a name="marker-302274"></a>EWOULDBLOCK] The socket is marked non-blocking and the receive operation would block.</p>
<p>[<a name="marker-302276"></a>EFAULT] The data was specified to be received into an invalid address.</p>
</dl>

<dt>
<h5><a name="idx-5664"></a>See also</h5>
<dd>
<p><A HREF="#50260">SOCKETREAD</a>, <A HREF="#79679">SEND</a>, <A HREF="#44018">SELECT</a>, <A HREF="#91651">GETSOCKOPT</a>, <A HREF="#85806">SOCKET</a></p>

<dt>
<h5><a name="idx-5665"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329668"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="99734"></a>RRESVPORT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5666"></a>Name</h5>
<dd>
<p><a name="marker-329673"></a>rresvport - routine for returning a stream to a remote command </p>

<dt>
<h5><a name="idx-5667"></a>Synopsis</h5>
<dd>
<p><pre>int rresvport(port);
int *port;</pre></p>

<dt>
<h5><a name="idx-5668"></a>Description</h5>
<dd>
<p>Rresvport is a routine which returns a descriptor to a socket with an address in the privileged port space bound to it. Privileged Internet ports are those in the range 0 to 1023.</p>

<dt>
<h5><a name="idx-5669"></a>Return value</h5>
<dd>
<p>Rresvport returns a valid, bound socket descriptor on success. It returns -1 on error with the global value errno set according to the reason for failure (see <A HREF="MODULES.HTML#90260">ERRNO</a>). The error code <a name="marker-329672"></a>EAGAIN is overloaded to mean 'All network ports in use'.</p>

<dt>
<h5><a name="idx-5670"></a>Exported by</h5>
<dd>
<p>Inetlib<a name="marker-329679"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="44018"></a>SELECT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5671"></a>Name</h5>
<dd>
<p>select - synchronous <a name="marker-328237"></a>socket I/O multiplexing</p>

<dt>
<h5><a name="idx-5672"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/types.h"
#include "sys/time.h"
int select (nfds,readfds,writefds,exceptfds,timeout)
int nfds;
fd_set *readfds, *writefds, *exceptfds;
struct timeval *timeout;
FD_SET(fd, &amp;fdset)
FD_CLR(fd, &amp;fdset)
FD_ISSET(fd, &amp;fdset)
FD_ZERO(&amp;fdset)
int fd;
fd_set fdset;</pre></p>

<dt>
<h5><a name="idx-5673"></a>Description</h5>
<dd>
<p><i>Select</i> examines the socket descriptor sets whose addresses are passed in <i>readfds</i>, <i>writefds</i>, and <i>exceptfds</i> to see if some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. The first <i>nfds</i> descriptors are checked in each set; ie the descriptors from 0 through <i>nfds</i>-1 in the descriptor sets are examined. On return, <i>select</i> replaces the given descriptor sets with subsets consisting of those descriptors that are ready for the requested operation. The total number of ready descriptors in all the sets is returned in <i>nfound</i>.</p>
<p>The descriptor sets are stored as bit fields in arrays of integers. The following macros are provided for manipulating such descriptor sets: <i>FD_ZERO(&amp;fdset)</i> initializes a descriptor set <i>fdset</i> to the null set. <i>FD_SET(fd, &amp;fdset)</i> includes a particular descriptor <i>fd</i> in <i>fdset</i>. <i>FD_CLR(fd, &amp;fdset)</i> removes <i>fd</i> from <i>fdset</i>. <i>FD_ISSET(fd, &amp;fdset)</i> is nonzero if <i>fd</i> is a member of <i>fdset</i>, zero otherwise. The behaviour of these macros is undefined if a descriptor value is less than zero or greater than or equal to <i>FD_SETSIZE</i>, which is normally at least equal to the maximum number of descriptors supported by the system.</p>
<p>If <i>timeout</i> is a non-zero pointer, it specifies a maximum interval to wait for the selection to complete. If <i>timeout</i> is a zero pointer, the select blocks indefinitely. To affect a poll, the <i>timeout</i> argument should be non-zero, pointing to a zero-valued timeval structure.</p>
<p>Any of <i>readfds</i>, <i>writefds</i>, and <i>exceptfds</i> may be given as zero pointers if no descriptors are of interest.</p>

<dt>
<h5><a name="idx-5674"></a>Return value</h5>
<dd>
<p><i>Select</i> returns the number of ready descriptors that are contained in the descriptor sets, or -1 if an error occurred. If the time limit expires then <i>select</i> returns 0. If <i>select</i> returns with an error, the descriptor sets will be unmodified.</p>

<dt>
<h5><a name="idx-5675"></a>Errors</h5>
<dd>
<p>An error return from <i>select</i> indicates:</p>
<dl>
<dd>
<p>[<a name="marker-302298"></a>EBADF] One of the descriptor sets specified an invalid descriptor.</p>
<p>[<a name="marker-302300"></a>EINVAL] The specified time limit is invalid. One of its components is negative or too large.</p>
</dl>

<dt>
<h5><a name="idx-5676"></a>See also</h5>
<dd>
<p><A HREF="#10536">ACCEPT</a>, <A HREF="#11499">CONNECT</a>, <A HREF="#50260">SOCKETREAD</a>, <A HREF="#10379">SOCKETWRITE</a></p>

<dt>
<h5><a name="idx-5677"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-328243"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="79679"></a>SEND</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5678"></a>Name</h5>
<dd>
<p>send, sendto, sendmsg - <a name="marker-302309"></a>send a message from a socket</p>

<dt>
<h5><a name="idx-5679"></a>Synopsis</h5>
<dd>
<p><pre>int send(s, msg, len, flags)
int s;
char *msg;
int len, flags;
#include "sys/socket.h"
#include "sys/types.h"
int sendto(s, msg, len, flags, to, tolen)
int s;
char *msg;
int len, flags;
struct sockaddr *to;
int tolen;
#include "sys/uio.h"
int sendmsg(s, msg, flags)
int s;
struct msghdr *msg;
int flags;</pre></p>

<dt>
<h5><a name="idx-5680"></a>Description</h5>
<dd>
<p><i>Send</i>, <i>sendto</i>, and <i>sendmsg</i> are used to transmit a message to another socket. <i>Send</i> may be used only when the socket is in a <i>connected</i> state, while <i>sendto</i> and <i>sendmsg</i> may be used at any time.</p>
<p>The address of the target is given by <i>to</i> with <i>tolen</i> specifying its size. The length of the message is given by <i>len</i>. If the message is too long to pass atomically through the underlying protocol, then the error EMSGSIZE is returned, and the message is not transmitted.</p>
<p>No indication of failure to deliver is implicit in a <i>send</i>. Return values of -1 indicate some locally detected errors.</p>
<p>If no messages space is available at the socket to hold the message to be transmitted, then <i>send</i> normally blocks, unless the socket has been placed in non-blocking I/O mode. The select call (<A HREF="#44018">SELECT</a>) may be used to determine when it is possible to send more data.</p>
<p>The <i>flags</i> parameter may be set to MSG_OOB (otherwise 0) to send 'out-of-band' data on sockets that support this notion (eg SOCK_STREAM); the underlying protocol must also support 'out-of-band' data.</p>
<p>See <i>recv</i> for a description of the <i>msghdr</i> structure.</p>

<dt>
<h5><a name="idx-5681"></a>Return value</h5>
<dd>
<p>The call returns the number of characters sent, or -1 if an error occurred.</p>

<dt>
<h5><a name="idx-5682"></a>Errors</h5>
<dd>
<p>The call fails if:</p>
<dl>
<dd>
<p>[<a name="marker-302326"></a>EBADF] An invalid descriptor was specified.</p>
<p>[<a name="marker-302328"></a>EFAULT] An invalid address was specified for a parameter.</p>
<p>[<a name="marker-302330"></a>EMSGSIZE] The socket requires that message be sent atomically, and the size of the message to be sent made this impossible.</p>
<p>[<a name="marker-302332"></a>EWOULDBLOCK] The socket is marked non-blocking and the requested operation would block.</p>
<p>[<a name="marker-302334"></a>ENOBUFS] The system was unable to allocate an internal buffer. The operation may succeed when buffers become available.</p>
<p>[<a name="marker-302336"></a>ENOBUFS] The output queue for a network interface was full. This generally indicates that the interface has stopped sending, but may be caused by transient congestion.</p>
</dl>

<dt>
<h5><a name="idx-5683"></a>See also</h5>
<dd>
<p><A HREF="#32246">RECV</a>, <A HREF="#44018">SELECT</a>, <A HREF="#91651">GETSOCKOPT</a>, <A HREF="#85806">SOCKET</a>, <A HREF="#10379">SOCKETWRITE</a></p>

<dt>
<h5><a name="idx-5684"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329710"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="57581"></a>SHUTDOWN</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5685"></a>Name</h5>
<dd>
<p>shutdown - shut down part of a full-duplex <a name="marker-302345"></a>connection</p>

<dt>
<h5><a name="idx-5686"></a>Synopsis</h5>
<dd>
<p><pre>int shutdown(s, how)
int s, how;</pre></p>

<dt>
<h5><a name="idx-5687"></a>Description</h5>
<dd>
<p>The <i>shutdown</i> call causes all or part of a full-duplex connection on the socket associated with <i>s</i> to be shut down. If <i>how</i> is 0, then further receives will be disallowed. If <i>how</i> is 1, then further sends will be disallowed. If <i>how</i> is 2, then further sends and receives will be disallowed.</p>

<dt>
<h5><a name="idx-5688"></a>Return value</h5>
<dd>
<p>A 0 return value indicates success; -1 indicates an error.</p>

<dt>
<h5><a name="idx-5689"></a>Errors</h5>
<dd>
<p>The call fails if:</p>
<dl>
<dd>
<p>[<a name="marker-302353"></a>EBADF] <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-302355"></a>ENOTCONN] The specified socket is not connected.</p>
<p>[<a name="marker-302357"></a>ENOTSOCK] <i>s</i> is a file, not a socket.</p>
</dl>

<dt>
<h5><a name="idx-5690"></a>See also</h5>
<dd>
<p><A HREF="#11499">CONNECT</a>, <A HREF="#85806">SOCKET</a></p>

<dt>
<h5><a name="idx-5691"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329716"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="85806"></a>SOCKET</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5692"></a>Name</h5>
<dd>
<p>socket - <a name="marker-302362"></a>create an endpoint for communication</p>

<dt>
<h5><a name="idx-5693"></a>Synopsis</h5>
<dd>
<p><pre>int socket(domain, type, protocol)
int domain, type, protocol;</pre></p>

<dt>
<h5><a name="idx-5694"></a>Description</h5>
<dd>
<p><i>Socket</i> creates an endpoint for communication and returns a descriptor.</p>
<p>The <i>domain</i> parameter specifies a communications domain within which communication will take place; this selects the protocol family which should be used. The protocol family generally is the same as the address family for the addresses supplied in later operations on the socket. The currently understood format under RISC OS is</p>
<dl>
<dd>
<table>
<tr>
<td align="left" valign="top">PF_INET
<td align="left" valign="top">(Internet protocols).
</table>
</dl>
<p>The socket has the indicated <i>type</i>, which specifies the semantics of communication. Currently defined types under RISC OS are:</p>
<dl>
<dd>
SOCK_STREAM<br>
SOCK_DGRAM<br>
SOCK_RAW
</dl>
<p>A SOCK_STREAM type provides sequenced, reliable, two-way connection based byte streams. An out-of-band data transmission mechanism may be supported. A SOCK_DGRAM socket supports datagrams (connectionless, unreliable messages of a fixed (typically small) maximum length). SOCK_RAW sockets provide access to internal network protocols and interfaces.</p>
<p>The <i>protocol</i> specifies a particular protocol to be used with the socket. Normally only a single protocol exists to support a particular socket type within a given protocol family. However, it is possible that many protocols may exist, in which case a particular protocol must be specified in this manner. The protocol number to use is particular to the 'communication domain' in which communication is to take place; see <A HREF="MODULES.HTML#51065">Protocols</a>.</p>
<p>Sockets of type SOCK_STREAM are full-duplex byte streams. A stream socket must be in a <i>connected</i> state before any data may be sent or received on it. A connection to another socket is created with a <i>connect</i> call. Once connected, data may be transferred using some variant of the <i>send</i> and <i>recv</i> calls. When a session has been completed a <i>socketclose</i> may be performed. Out-of-band data may also be transmitted as described in <i>send</i> and received as described in <i>recv</i>.</p>
<p>The communications protocols used to implement a SOCK_STREAM insure that data is not lost or duplicated. If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is considered broken and calls will indicate an error with -1 returns and with <a name="marker-302386"></a>ETIMEDOUT as the specific code in the global variable errno. The protocols optionally keep sockets 'warm' by forcing transmissions roughly every minute in the absence of other activity. An error is then indicated if no response can be elicited on an otherwise idle connection for a extended period (eg 5 minutes). An <i>Internet_Event/Socket_Broken_Event</i> event occurs if a program sends on a broken stream, provided the program has enabled the event (see <A HREF="#68725">The Internet event</a>)</p>
<p>SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in <i>send</i> calls. Datagrams are generally received with <i>recvfrom</i>, which returns the next datagram with its return address.</p>
<p>The operation of sockets is controlled by socket level <i>options</i>. These options are defined in the file <i>"sys/socket.h"</i>. <i>Setsockopt</i> and <i>getsockopt</i> are used to set and get options, respectively.</p>

<dt>
<h5><a name="idx-5695"></a>Return value</h5>
<dd>
<p>A -1 is returned if an error occurs, otherwise the return value is a descriptor referencing the socket.</p>

<dt>
<h5><a name="idx-5696"></a>Errors</h5>
<dd>
<p>The <i>socket</i> call fails if:</p>
<dl>
<dd>
<p>[<a name="marker-302397"></a>EPROTONOSUPPORT] The protocol type or the specified protocol is not supported within this domain.</p>
<p>[<a name="marker-302399"></a>EMFILE] The socket descriptor table is full.</p>
<p>[<a name="marker-302401"></a>EACCES] Permission to create a socket of the specified type and/or protocol is denied.</p>
<p>[<a name="marker-302403"></a>ENOBUFS] Insufficient buffer space is available. The socket cannot be created until sufficient resources are freed.</p>
</dl>

<dt>
<h5><a name="idx-5697"></a>See also</h5>
<dd>
<p><A HREF="#10536">ACCEPT</a>, <A HREF="#36015">BIND</a>, <A HREF="#11499">CONNECT</a>, <A HREF="#45457">GETSOCKNAME</a>, <A HREF="#91651">GETSOCKOPT</a>, <A HREF="#99356">SOCKETIOCTL</a>, <A HREF="#75746">LISTEN</a>, <A HREF="#50260">SOCKETREAD</a>, <A HREF="#32246">RECV</a>, <A HREF="#44018">SELECT</a>, <A HREF="#79679">SEND</a>, <A HREF="#57581">SHUTDOWN</a>, <A HREF="#10379">SOCKETWRITE</a></p>

<dt>
<h5><a name="idx-5698"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329725"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="77741"></a>SOCKETCLOSE</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5699"></a>Name</h5>
<dd>
<p>socketclose - close an open <a name="marker-302410"></a>socket</p>

<dt>
<h5><a name="idx-5700"></a>Synopsis</h5>
<dd>
<p><pre>int socketclose(s)
int s;</pre></p>

<dt>
<h5><a name="idx-5701"></a>Description</h5>
<dd>
<p><i>Socketclose</i> closes an open socket, and releases any resources, including queued data, associated with it.</p>
<p>Because RISC OS uses a global descriptor table, you can close another program's socket. You must therefore take care that the socket descriptor passed belongs to your program.</p>
<p>If an application terminates under RISC OS without closing an open socket, then that socket will remain open indefinitely, needlessly consuming resources. You therefore <b>must</b> ensure your applications close all sockets before quitting.</p>

<dt>
<h5><a name="idx-5702"></a>Return value</h5>
<dd>
<p>Upon successful completion, a value of 0 is returned. Otherwise, a value of -1 is returned and the global integer variable <i>errno</i> is set to indicate the error.</p>

<dt>
<h5><a name="idx-5703"></a>Errors</h5>
<dd>
<p>The call will fail if:</p>
<dl>
<dd>
<p>[<a name="marker-302418"></a>EBADF] <i>s</i> is not a valid descriptor.</p>
</dl>

<dt>
<h5><a name="idx-5704"></a>See also</h5>
<dd>
<p><A HREF="#93405">CLOSE</a>, <A HREF="#10536">ACCEPT</a>, <A HREF="#85806">SOCKET</a></p>

<dt>
<h5><a name="idx-5705"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329731"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="99356"></a>SOCKETIOCTL</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5706"></a>Name</h5>
<dd>
<p>socketioctl - control an open <a name="marker-302423"></a>socket</p>

<dt>
<h5><a name="idx-5707"></a>Synopsis</h5>
<dd>
<p><pre>int socketioctl(s, request, argp)
int s;
unsigned long request;
void *argp;</pre></p>

<dt>
<h5><a name="idx-5708"></a>Description</h5>
<dd>
<p><i>Socketioctl</i> is used to alter the operating characteristics of an open socket, <i>s</i>. The parameter <i>request</i> specifies the socketioctl command, and has encoded within it both the size of the argument pointed to by <i>argp</i>, and whether the argument is an 'in' parameter or an 'out' parameter. Macros and defines used in specifying a socketioctl <i>request</i> are located in the header file <i>"sys/ioctl.h"</i>.</p>

<dt>
<h5><a name="idx-5709"></a>Return value</h5>
<dd>
<p>If an error has occurred, a value of -1 is returned and errno is set to indicate the error.</p>

<dt>
<h5><a name="idx-5710"></a>Errors</h5>
<dd>
<p>The call will fail if:</p>
<dl>
<dd>
<p>[<a name="marker-302432"></a>EBADF] <i>s</i> is not a valid descriptor.</p>
<p>[<a name="marker-329737"></a>ENOTTY] The specified request does not apply to the kind of object that the descriptor <i>d</i> references.</p>
<p>[<a name="marker-329738"></a>EINVAL] <i>Request</i> or <i>argp</i> is not valid.</p>
</dl>

<dt>
<h5><a name="idx-5711"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329504"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="50260"></a>SOCKETREAD</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5712"></a>Name</h5>
<dd>
<p><a name="marker-329740"></a>socketread, socketreadv - read input</p>

<dt>
<h5><a name="idx-5713"></a>Synopsis</h5>
<dd>
<p><pre>int socketread(d, buf, nbytes)
int d;
char *buf;
int nbytes;
#include "sys/types.h"
#include "sys/uio.h"
int socketreadv(d, iov, iovcnt)
int cc, d;
struct iovec *iov;
int iovcnt;</pre></p>

<dt>
<h5><a name="idx-5714"></a>Description</h5>
<dd>
<p>Socketread attempts to read nbytes of data from the object referenced by the descriptor d into the buffer pointed to by buf. Socketreadv performs the same action, but scatters the input data into the iovcnt buffers specified by the members of the iov array: iov[0], iov[1], ..., iov[iovcnt-1].</p>
<p>For socketreadv, the iovec structure is defined as</p>
<dl>
<dd>
<pre>struct iovec
{
  caddr_t iov_base;
  int     iov_len;
};</pre>
</dl>
<p>Each iovec entry specifies the base address and length of an area in memory where data should be placed. Socketreadv will always fill an area completely before proceeding to the next.</p>
<p>Upon successful completion, socketread and socketreadv return the number of bytes actually read and placed in the buffer. The system guarantees to read the number of bytes requested if the descriptor references a normal file that has that many bytes left before the end-of-file, but in no other case.</p>
<p>If the returned value is 0, then end-of-file has been reached.</p>

<dt>
<h5><a name="idx-5715"></a>Return value</h5>
<dd>
<p>If successful, the number of bytes actually read is returned. Otherwise, a -1 is returned and the global variable errno is set to indicate the error.</p>

<dt>
<h5><a name="idx-5716"></a>Errors</h5>
<dd>
<p>Socketread and socketreadv will fail if one or more of the following are true:</p>
<dl>
<dd>
<p>[<a name="marker-329753"></a>EBADF] D is not a valid socket descriptor open for reading.</p>
<p>[<a name="marker-329754"></a>EFAULT] Buf points outside the allocated address space.</p>
<p>[<a name="marker-329755"></a>EIO] An I/O error occurred while reading from the socket.</p>
<p>[<a name="marker-329756"></a>EINTR] A read from a slow device was interrupted before any data arrived.</p>
<p>[<a name="marker-329757"></a>EINVAL] The pointer associated with d was negative.</p>
<p>[<a name="marker-329758"></a>EWOULDBLOCK] The socket was marked for non-blocking I/O, and no data were ready to be read.</p>
</dl>
<p>In addition, socketreadv may return one of the following errors:</p>
<dl>
<dd>
<p>[<a name="marker-329759"></a>EINVAL] Iovcnt was less than or equal to 0, or greater than 16.</p>
<p>[<a name="marker-329760"></a>EINVAL] One of the iov_len values in the iov array was negative.</p>
<p>[<a name="marker-329761"></a>EINVAL] The sum of the iov_len values in the iov array overflowed a 32-bit integer.</p>
<p>[<a name="marker-329762"></a>EFAULT] Part of the iov points outside the program's allocated address space.</p>
</dl>

<dt>
<h5><a name="idx-5717"></a>See also</h5>
<dd>
<p><A HREF="#44018">SELECT</a>, <A HREF="#85806">SOCKET</a></p>

<dt>
<h5><a name="idx-5718"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329742"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="11589"></a>SOCKETSTAT</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5719"></a>Name</h5>
<dd>
<p>socketstat - get <a name="marker-329746"></a>socket status</p>

<dt>
<h5><a name="idx-5720"></a>Synopsis</h5>
<dd>
<p><pre>#include "sys/types.h"
#include "sys/stat.h"
int socketstat(s, buf)
int s;
struct stat *buf;</pre></p>

<dt>
<h5><a name="idx-5721"></a>Description</h5>
<dd>
<p>Socketstat obtains information about the socket descriptor s.</p>
<p>Buf is a pointer to a stat structure into which information is placed concerning the socket. The contents of the structure pointed to by buf are:</p>
<dl>
<dd>
<pre>struct stat
{
  dev_t   st_dev;        /* device inode resides on */
  ino_t   st_ino;        /* this inode's number */
  u_short st_mode;       /* protection */
  short   st_nlink;      /* number or hard links to the file */
  uid_t   st_uid;        /* user-id of owner */
  gid_t   st_gid;        /* group-id of owner */
  dev_t   st_rdev;       /* device type, for inode that is device */
  off_t   st_size;       /* total size of file */
  time_t  st_atime;      /* file last access time */
  int     st_spare1;
  time_t  st_mtime;      /* file last modify time */
  int     st_spare2;
  time_t  st_ctime;      /* file last status change time */
  int     st_spare3;
  long    st_blksize;    /* optimal blocksize for file system i/o */
  long    st_blocks;     /* actual number of blocks allocated */
  long    st_spare4[2];
};</pre>
</dl>
<p>The st_blksize field may be either updated or preserved, depending on the socket's protocol. All other fields have little or no meaning for sockets, and are preserved.</p>

<dt>
<h5><a name="idx-5722"></a>Return value</h5>
<dd>
<p>Upon successful completion a value of 0 is returned. Otherwise, a value of -1 is returned and errno is set to indicate the error.</p>

<dt>
<h5><a name="idx-5723"></a>Errors</h5>
<dd>
<p>Socketstat will fail if one or more of the following are true:</p>
<dl>
<dd>
<p>[<a name="marker-319390"></a>EBADF] <i>s</i> is not a valid descriptor.</p>
</dl>

<dt>
<h5><a name="idx-5724"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329748"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="10379"></a>SOCKETWRITE</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5725"></a>Name</h5>
<dd>
<p><a name="marker-329763"></a>socketwrite, socketwritev - write output</p>

<dt>
<h5><a name="idx-5726"></a>Synopsis</h5>
<dd>
<p><pre>int socketwrite(d, buf, nbytes)
int d;
char *buf;
int nbytes;
#include "sys/types.h"
#include "sys/uio.h"
int socketwritev(d, iov, iovcnt)
int d;
struct iovec *iov;
int iovcnt;</pre></p>

<dt>
<h5><a name="idx-5727"></a>Description</h5>
<dd>
<p>Socketwrite attempts to write nbytes of data to the object referenced by the descriptor d from the buffer pointed to by buf. Socketwritev performs the same action, but gathers the output data from the iovcnt buffers specified by the members of the iov array: iov[0], iov[1], ..., iov[iovcnt-1].</p>
<p>For socketwritev, the iovec structure is defined as</p>
<dl>
<dd>
<pre>struct iovec
{
  caddr_t iov_base;
  int     iov_len;
};</pre>
</dl>
<p>Each iovec entry specifies the base address and length of an area in memory from which data should be written. Socketwritev will always write a complete area before proceeding to the next.</p>
<p>Sockets are subject to flow control, so socketwrite and socketwritev may write fewer bytes than requested; the return value must be noted, and the remainder of the operation should be retried when possible.</p>

<dt>
<h5><a name="idx-5728"></a>Return value</h5>
<dd>
<p>Upon successful completion the number of bytes actually written is returned. Otherwise a -1 is returned and the global variable errno is set to indicate the error.</p>

<dt>
<h5><a name="idx-5729"></a>Errors</h5>
<dd>
<p>Socketwrite and socketwritev will fail and the file pointer will remain unchanged if one or more of the following are true:</p>
<dl>
<dd>
<p>[<a name="marker-329769"></a>EBADF] D is not a valid descriptor open for writing.</p>
<p>[<a name="marker-329770"></a>EPIPE] An attempt is made to write to a socket of type SOCK_STREAM that is not connected to a peer socket.</p>
<p>[<a name="marker-329771"></a>EFAULT] Part of iov or data to be written to the socket points outside the program's allocated address space.</p>
<p>[<a name="marker-329772"></a>EINVAL] The pointer associated with d was negative.</p>
<p>[<a name="marker-329773"></a>EIO] An I/O error occurred while reading from or writing to the socket.</p>
<p>[<a name="marker-329774"></a>EWOULDBLOCK] The socket was marked for non-blocking I/O, and no data could be written immediately.</p>
</dl>
<p>In addition, socketwritev may return one of the following errors:</p>
<dl>
<dd>
<p>[<a name="marker-329775"></a>EINVAL] Iovcnt was less than or equal to 0, or greater than 16.</p>
<p>[<a name="marker-329776"></a>EINVAL] One of the iov_len values in the iov array was negative.</p>
<p>[<a name="marker-329777"></a>EINVAL] The sum of the iov_len values in the iov array overflowed a 32-bit integer.</p>
</dl>

<dt>
<h5><a name="idx-5730"></a>See also</h5>
<dd>
<p><A HREF="#44018">SELECT</a></p>

<dt>
<h5><a name="idx-5731"></a>Exported by</h5>
<dd>
<p>Socklib<a name="marker-329765"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="52893"></a>STRING</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5732"></a>Name</h5>
<dd>
<p><a name="marker-329778"></a>strcasecmp, strncasecmp, <a name="marker-329784"></a>index, rindex - string operations</p>

<dt>
<h5><a name="idx-5733"></a>Synopsis</h5>
<dd>
<p><pre>int strcasecmp(s1, s2)
char *s1, *s2;
int strncasecmp(s1, s2, n)
char *s1, *s2;
int n
char *index(s, c)
char *s, c;
char *rindex(s, c)
char *s, c;</pre></p>

<dt>
<h5><a name="idx-5734"></a>Description</h5>
<dd>
<p>These functions operate on null-terminated strings. They do not check for overflow of any receiving string.</p>
<p>Strcasecmp compares its arguments and returns an integer of 1 or 0, according as s1 is lexicographically not equal to, or equal to s2. Strncasecmp makes the same comparison but looks at at most n characters.</p>
<p>Index (rindex) returns a pointer to the first (last) occurrence of character c in string s, or zero if c does not occur in the string.</p>

<dt>
<h5><a name="idx-5735"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329780"></a><a name="marker-329786"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="83611"></a>UNLINK</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5736"></a>Name</h5>
<dd>
<p><a name="marker-329588"></a>unlink - remove directory entry</p>

<dt>
<h5><a name="idx-5737"></a>Synopsis</h5>
<dd>
<p><pre>int unlink(path)
char *path;</pre></p>

<dt>
<h5><a name="idx-5738"></a>Description</h5>
<dd>
<p>Unlink removes the entry for the object path from its directory. The call fails if the object is locked against deletion, or if it is a directory which is not empty, or if it is already open.</p>

<dt>
<h5><a name="idx-5739"></a>Return value</h5>
<dd>
<p>A value of 0 is always returned.</p>

<dt>
<h5><a name="idx-5740"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329593"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="34430"></a>_VARNAMEBUF</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5741"></a>Name</h5>
<dd>
<p>_varnamebuf - call for internal use only</p>

<dt>
<h5><a name="idx-5742"></a>Synopsis</h5>
<dd>
<p>--</p>

<dt>
<h5><a name="idx-5743"></a>Description</h5>
<dd>
<p>The _varnamebuf symbol is exported for internal use only. You must not use it in your own code.</p>

<dt>
<h5><a name="idx-5744"></a>Exported by</h5>
<dd>
<p>Unixlib</p>
</dl>
<dt>
<hr><h2 align="right"><a name="63426"></a>WRITE</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5745"></a>Name</h5>
<dd>
<p><a name="marker-329790"></a>write, writev - write output</p>

<dt>
<h5><a name="idx-5746"></a>Synopsis</h5>
<dd>
<p><pre>int write(d, buf, nbytes)
int d;
char *buf;
int nbytes;
#include "sys/types.h"
#include "sys/uio.h"
int writev(d, iov, iovcnt)
int d;
struct iovec *iov;
int iovcnt;</pre></p>

<dt>
<h5><a name="idx-5747"></a>Description</h5>
<dd>
<p>Write is a synonym for socketwrite, and writev a synonym for socketwritev; see <A HREF="#10379">SOCKETWRITE</a>. These calls are provided mainly so that you do not need to rename write and writev calls in code that you are porting.</p>

<dt>
<h5><a name="idx-5748"></a>See also</h5>
<dd>
<p>socketwrite and socketwritev (<A HREF="#10379">SOCKETWRITE</a>)</p>

<dt>
<h5><a name="idx-5749"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329792"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="92110"></a>XGETS</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5750"></a>Name</h5>
<dd>
<p><a name="marker-329800"></a>xgets - get a string from a stream</p>

<dt>
<h5><a name="idx-5751"></a>Synopsis</h5>
<dd>
<p><pre>char *xgets(s)
char *s;</pre></p>

<dt>
<h5><a name="idx-5752"></a>Description</h5>
<dd>
<p>Xgets reads a string into s from the current input stream. The string is terminated by a return character, which is replaced in s by a linefeed character; or by EOF. The last character read into s is followed by a null character. Xgets returns its argument.</p>

<dt>
<h5><a name="idx-5753"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329805"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="64687"></a>XPERROR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5754"></a>Name</h5>
<dd>
<p><a name="marker-329809"></a>xperror, sys_errlist, sys_nerr - system error messages</p>

<dt>
<h5><a name="idx-5755"></a>Synopsis</h5>
<dd>
<p><pre>void xperror(s)
const char *s;
char *sys_errlist[];
int sys_nerr;</pre></p>

<dt>
<h5><a name="idx-5756"></a>Description</h5>
<dd>
<p>Xperror produces a short error message on the current output stream describing the last error encountered during a call to the system from a C program. First the argument string s is printed, then a colon, then the message and a new-line. Most usefully, the argument string is the name of the program which incurred the error. The error number is taken from the external variable errno, which is set when errors occur but not cleared when non-erroneous calls are made.</p>
<p>To simplify variant formatting of messages, the vector of message strings sys_errlist is provided; errno can be used as an index in this table to get the message string without the newline. Sys_nerr is the number of messages provided for in the table; it should be checked because new error codes may be added to the system before they are added to the table. Indeed, xperror makes such a check, and outputs a default message string if errno exceeds sys_nerr.</p>

<dt>
<h5><a name="idx-5757"></a>See also</h5>
<dd>
<p><A HREF="MODULES.HTML#90260">ERRNO</a></p>

<dt>
<h5><a name="idx-5758"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329811"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="35693"></a>XPUTCHAR</h2>
<dd>
<dl>

<dt>
<h5><a name="idx-5759"></a>Name</h5>
<dd>
<p>xputchar - put <a name="marker-329815"></a>character or word on a stream</p>

<dt>
<h5><a name="idx-5760"></a>Synopsis</h5>
<dd>
<p><pre>char xputchar(c)
char c;</pre></p>

<dt>
<h5><a name="idx-5761"></a>Description</h5>
<dd>
<p>Xputchar appends the character c to the current output stream. It returns the character written.</p>

<dt>
<h5><a name="idx-5762"></a>Exported by</h5>
<dd>
<p>Unixlib<a name="marker-329817"></a><a name="marker-328868"></a><a name="marker-328869"></a><a name="marker-328870"></a></p>
</dl>

<dt>
<h2><a name="88077"></a>Service calls</h2>
<dd>
<dl>
<dd>
<p>This section documents the service calls that are used to communicate between <a name="marker-329821"></a>network device drivers and the rest of RISC OS. Unfortunately, you need to know and understand the <a name="marker-329823"></a>Driver Control Interface specification before you can follow all the details of these descriptions, and that is beyond the scope of this manual to document. See <A HREF="AUN.HTML#35811">The software in detail</a>.</p>
</dl>

<dt>
<h4><a name="69510"></a>Driver information blocks</h4>
<dd>
<dl>
<dd>
<p>A device driver identifies each logical interface it controls by a <i>driver information block</i><a name="marker-329829"></a>. These are used by a number of the service calls that follow, and have the following structure:</p>
<dl>
<dd>
<table>
<tr>
<th align="left" valign="top">Offset
<th align="left" valign="top" colspan="4">Value
<tr>
<td align="left" valign="top">0
<td align="left" valign="top" colspan="4">The base of the device driver's allocated SWI chunk
<tr>
<td align="left" valign="top">4
<td align="left" valign="top" colspan="4">Pointer to the device driver's unique short name, null terminated (eg 'en', 'ppp')
<tr>
<td align="left" valign="top">8
<td align="left" valign="top" colspan="4">The unit number
<tr>
<td align="left" valign="top">12
<td align="left" valign="top" colspan="4">Pointer to 6 bytes giving the hardware address of the interface
<tr>
<td align="left" valign="top">16
<td align="left" valign="top" colspan="4">Pointer to the device driver's title, null terminated (eg 'Ether3')
<tr>
<td align="left" valign="top">20
<td align="left" valign="top" colspan="4">Pointer to a string describing the physical location of the interface, null terminated (eg 'Network Expansion Slot', 'Expansion Slot 0, port #1')
<tr>
<td align="left" valign="top">24
<td align="left" valign="top" colspan="4">Bitfield specifying physical slot:
<tr>
<td align="left" valign="top" colspan="2" rowspan="4">
<td align="left" valign="top" nowrap>bits 0 - 7
<td align="left" valign="top">slot number:
<td align="left" valign="top">0 - 7 =&GT; physical expansion card slot
8 =&GT; network expansion card slot<br>
128 =&GT; parallel port<br>
129 =&GT; Serial port (eg PPP)<br>
130 =&GT; Econet socket<br>
131 =&GT; PCMCIA card
<tr>
<td align="left" valign="top" nowrap>bits 8 - 15
<td align="left" valign="top" colspan="2">reserved for device driver's use: may be used where one card provides multiple independent interfaces
<tr>
<td align="left" valign="top" nowrap>bits 16 - 20
<td align="left" valign="top" colspan="2">physical PCMCIA slot, used when slot number is 131
<tr>
<td align="left" valign="top" nowrap>bits 21 -31
<td align="left" valign="top" colspan="2">reserved - must be zero
<tr>
<td align="left" valign="top">28
<td align="left" valign="top" colspan="4">Bitfield giving characteristics of device driver; meaning when set is:
<tr>
<td align="left" valign="top" colspan="2" rowspan="12">
<td align="left" valign="top" nowrap>bit 0
<td align="left" valign="top" colspan="2">multicast reception is supported
<tr>
<td align="left" valign="top" nowrap>bit 1
<td align="left" valign="top" colspan="2">promiscuous reception is supported
<tr>
<td align="left" valign="top" nowrap>bit 2
<td align="left" valign="top" colspan="2">interface receives its own transmitted packets
<tr>
<td align="left" valign="top" nowrap>bit 3
<td align="left" valign="top" colspan="2">station number required
<tr>
<td align="left" valign="top" nowrap>bit 4
<td align="left" valign="top" colspan="2">interface can receive erroneous packets
<tr>
<td align="left" valign="top" nowrap>bit 5
<td align="left" valign="top" colspan="2">interface has a hardware address
<tr>
<td align="left" valign="top" nowrap>bit 6
<td align="left" valign="top" colspan="2">driver can alter interface's hardware address
<tr>
<td align="left" valign="top" nowrap>bit 7
<td align="left" valign="top" colspan="2">interface is a point to point link
<tr>
<td align="left" valign="top" nowrap>bit 8
<td align="left" valign="top" colspan="2">driver supplies standard statistics
<tr>
<td align="left" valign="top" nowrap>bit 9
<td align="left" valign="top" colspan="2">driver supplies extended statistics
<tr>
<td align="left" valign="top" nowrap>bit 10
<td align="left" valign="top" colspan="2">interface is virtual (ie a software emulation of hardware); refer to the Driver Control Interface specification
<tr>
<td align="left" valign="top" nowrap>bits 11 - 31
<td align="left" valign="top" colspan="2">reserved - must be zero
</table>
</dl>
<p>Each driver information block must be held as static data. In this way, protocol modules can identify an interface simply by comparing the addresses of driver information blocks, rather than by laboriously comparing fields within the block.</p>
<p>This does mean that any use of the *<a name="marker-329835"></a>RMTidy command will kill any network stack on the machine. In practice this is unlikely to be a great problem, since this command has long been deprecated.</p>
<p>The service call <A HREF="#19589">Service_DCIDriverStatus</a> provides a mechanism for a device driver module that is re-initialised (via *RMReInit) to pass the new address of its driver information block to a protocol module.<a name="marker-329831"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="70846"></a>Service_EnumerateNetworkDrivers<br>(Service Call &amp;9B)</h2>
<dd>
<dl>
<dd>
<p><a name="88133"></a>Issued to obtain a linked list of all active <a name="marker-329836"></a>network device drivers</p>

<dt>
<h5><a name="idx-5763"></a>On entry</h5>
<dd>
<p>R0 = pointer to head of linked list of network device drivers<br>
R1 = &amp;9B (reason code)</p>

<dt>
<h5><a name="idx-5764"></a>On exit</h5>
<dd>
<p>R0 = pointer to new head of linked list of network device drivers<br>
R1 preserved to pass on call</p>

<dt>
<h5><a name="idx-5765"></a>Use</h5>
<dd>
<p>This service call is issued to obtain a linked list of all active network device driver modules in the system. When the service call is first issued, R0 is a null pointer. When a device driver receives this call, it should chain an entry to the <b>head</b> of the linked list for each logical interface it controls. Each entry is as follows:</p>
<dl>
<dd>
<table>
<tr>
<th align="left" valign="top">Offset
<th align="left" valign="top">Value
<tr>
<td align="left" valign="top">0
<td align="left" valign="top">Pointer to the next entry in the linked list; the last entry is null
<tr>
<td align="left" valign="top">4
<td align="left" valign="top">Pointer to the driver information block for this entry
</table>
</dl>
<p>These entries are transient objects: the device drivers should allocate the space for them from RMA using <A HREF="MODULES.HTML#64895">OS_Module 6</a>, and the program that issued the service call should free them back into RMA using <A HREF="MODULES.HTML#70545">OS_Module 7</a> after the call returns. However, the driver information blocks referenced by each entry in the linked list must be static data; see <A HREF="#69510">Driver information blocks</a>.</p>
<p>You must not claim this service call.<a name="marker-329838"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="19589"></a>Service_DCIDriverStatus<br>(Service Call &amp;9D)</h2>
<dd>
<dl>
<dd>
<p><a name="32197"></a>Issued by a <a name="marker-329842"></a>network device driver module once initialised, and when <a name="marker-329848"></a>finalising</p>

<dt>
<h5><a name="idx-5766"></a>On entry</h5>
<dd>
<p>R0 = pointer to driver information block for starting/terminating driver<br>
R1 = &amp;9D (reason code)<br>
R2 = status (0 =&GT; starting, 1 =&GT; terminating)<br>
R3 = DCI version supported &times; 100 (eg 403 for version 4.03)</p>

<dt>
<h5><a name="idx-5767"></a>On exit</h5>
<dd>
<p>R0 - R3 preserved</p>

<dt>
<h5><a name="idx-5768"></a>Use</h5>
<dd>
<p>This service call is issued by a network device driver module once it has initialised and is ready to accept SWI calls (R2 = 0), and when it is finalising and can no longer accept SWI calls (R2 = 1). If the device driver controls multiple logical interfaces, it issues this service call once for each interface.</p>
<p>When a protocol module receives this service call from a driver that is starting up (ie R2 = 0), it should add the driver to its list of device drivers. When a protocol module receives the call from a driver that is terminating (ie R2 = 1), it should scan its list of device drivers for a driver information block matching the one addressed by R0, and remove the corresponding driver from the list.</p>
<p>You may instead decide to keep a terminating driver on the list, but to mark it as inactive in case it later restarts. If you do this, you must not match driver information blocks by comparing their addresses, as when a driver restarts the block may well be in a different location. You instead have to match fields within the driver information block: the short name and unit number (at offsets 4 and 8 respectively) together uniquely identify a driver information block, and so a match of them is sufficient.</p>
<p>You must not claim this service call.<a name="marker-329844"></a><a name="marker-329850"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="37304"></a>Service_DCIFrameTypeFree<br>(Service Call &amp;9E)</h2>
<dd>
<dl>
<dd>
<p>This Service Call requires you to use the Driver Control Interface, and so is beyond the scope of this manual to document. See <A HREF="AUN.HTML#35811">The software in detail</a>.</p>
</dl>
<dt>
<hr><h2 align="right"><a name="61663"></a>Service_DCIProtocolStatus<br>(Service Call &amp;9F)</h2>
<dd>
<dl>
<dd>
<p><a name="82239"></a>Issued by a <a name="marker-329854"></a>protocol module once it has initialised, and when it is finalising</p>

<dt>
<h5><a name="idx-5769"></a>On entry</h5>
<dd>
<p>R0 = protocol module's private word pointer<br>
R1 = &amp;9F (reason code)<br>
R2 = status (0 =&GT; starting, 1 =&GT; terminating)<br>
R3 = DCI version supported &times; 100 (eg 403 for version 4.03)<br>
R4 = pointer to protocol module's title string</p>

<dt>
<h5><a name="idx-5770"></a>On exit</h5>
<dd>
<p>R0 - R4 preserved</p>

<dt>
<h5><a name="idx-5771"></a>Use</h5>
<dd>
<p>This service call is issued by a protocol module once it has initialised and is ready to accept SWI calls (R2 = 0), and when it is finalising and can no longer accept SWI calls (R2 = 1).</p>
<p>The title string pointed to by R4 should be identical to the title string in the protocol module's header. This string is not used anywhere else in the DCI. (It is intended for use by modules that rely on the protocol module, but which do not communicate with it via the DCI; these modules need to have the name of significant protocol modules built into them.)</p>
<p>When a terminating protocol module issues this service call, it must continue handling receive events for all frame types it has not explicitly relinquished, until the service call returns. Once the call has returned, device drivers should have deleted <b>all</b> references to the protocol module which issued the service call.</p>
<p>This supersedes the unnamed service call &amp;41200, which was never part of any formal DCI specification, but which used to be issued during finalisation of the Internet module.</p>
<p>You must not claim this service call.<a name="marker-329825"></a><a name="marker-329856"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="84832"></a>Service_InternetStatus<br>(Service Call &amp;B0)</h2>
<dd>
<dl>
<dd>
<p><a name="88058"></a>Issued by the <a name="marker-329860"></a>Internet module when an interface address has been changed</p>

<dt>
<h5><a name="idx-5772"></a>On entry</h5>
<dd>
<p>R0 = 0 (subreason code)<br>
R1 = &amp;B0 (reason code)</p>

<dt>
<h5><a name="idx-5773"></a>On exit</h5>
<dd>
<p>R0, R1 preserved</p>

<dt>
<h5><a name="idx-5774"></a>Use</h5>
<dd>
<p>This service call is issued by the Internet module upon successful completion of an SIOCSIFADDR socketioctl() call; ie when an interface address has been changed.</p>
<p>You must not claim this service call.<a name="marker-329862"></a></p>
</dl>

<dt>
<h2><a name="15833"></a>SWI calls</h2>
<dd>
<dl>
<dd>
<p>There is a direct SWI equivalent to each call available in Socklib. In fact when you make a call to <a name="marker-303565"></a>Socklib, all that happens is that the parameters you pass are loaded into the ARM processor's registers, and the relevant SWI is issued; any returned RISC OS error block is converted to a C error number.</p>
</dl>

<dt>
<h4><a name="idx-5775"></a>Calling the SWIs</h4>
<dd>
<dl>
<dd>
<p>You may wish to issue the SWIs yourself - say if you're programming in BASIC. The table below shows you how each Socket_... SWI corresponds to the Socklib calls documented elsewhere in this chapter, giving the name and number of the SWI, the equivalent Socklib call, and the page on which it is documented:</p>
<dl>
<dd>
<table>
<tr>
<th align="left" valign="top">SWI name
<th align="left" valign="top">SWI no
<th align="left" valign="top">Socklib call
<th align="left" valign="top">Page
<tr>
<td align="left" valign="top"><a name="marker-311601"></a>Socket_Accept
<td align="left" valign="top">&amp;41203
<td align="left" valign="top">accept
<td align="left" valign="top"><A HREF="#10536">ACCEPT</a>
<tr>
<td align="left" valign="top">Socket_Bind
<td align="left" valign="top">&amp;41201
<td align="left" valign="top">bind
<td align="left" valign="top"><A HREF="#36015">BIND</a>
<tr>
<td align="left" valign="top">Socket_Close
<td align="left" valign="top">&amp;41210
<td align="left" valign="top">socketclose
<td align="left" valign="top"><A HREF="#77741">SOCKETCLOSE</a>
<tr>
<td align="left" valign="top">Socket_Connect
<td align="left" valign="top">&amp;41204
<td align="left" valign="top">connect
<td align="left" valign="top"><A HREF="#11499">CONNECT</a>
<tr>
<td align="left" valign="top">Socket_Creat
<td align="left" valign="top">&amp;41200
<td align="left" valign="top">socket
<td align="left" valign="top"><A HREF="#85806">SOCKET</a>
<tr>
<td align="left" valign="top">Socket_Getpeername
<td align="left" valign="top">&amp;4120E
<td align="left" valign="top">getpeername
<td align="left" valign="top"><A HREF="#99966">GETPEERNAME</a>
<tr>
<td align="left" valign="top">Socket_Getsockname
<td align="left" valign="top">&amp;4120F
<td align="left" valign="top">getsockname
<td align="left" valign="top"><A HREF="#45457">GETSOCKNAME</a>
<tr>
<td align="left" valign="top">Socket_Getsockopt
<td align="left" valign="top">&amp;4120D
<td align="left" valign="top">getsockopt
<td align="left" valign="top"><A HREF="#91651">GETSOCKOPT</a>
<tr>
<td align="left" valign="top">Socket_Gettsize
<td align="left" valign="top">&amp;41218
<td align="left" valign="top">getstablesize
<td align="left" valign="top"><A HREF="#32962">GETSTABLESIZE</a>
<tr>
<td align="left" valign="top">Socket_Ioctl
<td align="left" valign="top">&amp;41212
<td align="left" valign="top">socketioctl
<td align="left" valign="top"><A HREF="#99356">SOCKETIOCTL</a>
<tr>
<td align="left" valign="top">Socket_Listen
<td align="left" valign="top">&amp;41202
<td align="left" valign="top">listen
<td align="left" valign="top"><A HREF="#75746">LISTEN</a>
<tr>
<td align="left" valign="top">Socket_Read
<td align="left" valign="top">&amp;41213
<td align="left" valign="top">socketread
<td align="left" valign="top"><A HREF="#50260">SOCKETREAD</a>
<tr>
<td align="left" valign="top">Socket_Readv
<td align="left" valign="top">&amp;41216
<td align="left" valign="top">socketreadv
<td align="left" valign="top"><A HREF="#50260">SOCKETREAD</a>
<tr>
<td align="left" valign="top">Socket_Recv
<td align="left" valign="top">&amp;41205
<td align="left" valign="top">recv
<td align="left" valign="top"><A HREF="#32246">RECV</a>
<tr>
<td align="left" valign="top">Socket_Recvfrom
<td align="left" valign="top">&amp;41206
<td align="left" valign="top">recvfrom
<td align="left" valign="top"><A HREF="#32246">RECV</a>
<tr>
<td align="left" valign="top">Socket_Recvmsg
<td align="left" valign="top">&amp;41207
<td align="left" valign="top">recvmsg
<td align="left" valign="top"><A HREF="#32246">RECV</a>
<tr>
<td align="left" valign="top">Socket_Select
<td align="left" valign="top">&amp;41211
<td align="left" valign="top">select
<td align="left" valign="top"><A HREF="#44018">SELECT</a>
<tr>
<td align="left" valign="top">Socket_Send
<td align="left" valign="top">&amp;41208
<td align="left" valign="top">send
<td align="left" valign="top"><A HREF="#79679">SEND</a>
<tr>
<td align="left" valign="top">Socket_Sendmsg
<td align="left" valign="top">&amp;4120A
<td align="left" valign="top">sendmsg
<td align="left" valign="top"><A HREF="#79679">SEND</a>
<tr>
<td align="left" valign="top">Socket_Sendto
<td align="left" valign="top">&amp;41209
<td align="left" valign="top">sendto
<td align="left" valign="top"><A HREF="#79679">SEND</a>
<tr>
<td align="left" valign="top">Socket_Sendtosm
<td align="left" valign="top">&amp;41219
<td align="left" valign="top"><i>Reserved for internal use</i>
<td align="left" valign="top">--
<tr>
<td align="left" valign="top">Socket_Setsockopt
<td align="left" valign="top">&amp;4120C
<td align="left" valign="top">setsockopt
<td align="left" valign="top"><A HREF="#91651">GETSOCKOPT</a>
<tr>
<td align="left" valign="top">Socket_Shutdown
<td align="left" valign="top">&amp;4120B
<td align="left" valign="top">shutdown
<td align="left" valign="top"><A HREF="#57581">SHUTDOWN</a>
<tr>
<td align="left" valign="top">Socket_Stat
<td align="left" valign="top">&amp;41215
<td align="left" valign="top">socketstat
<td align="left" valign="top"><A HREF="#11589">SOCKETSTAT</a>
<tr>
<td align="left" valign="top">Socket_Write
<td align="left" valign="top">&amp;41214
<td align="left" valign="top">socketwrite
<td align="left" valign="top"><A HREF="#10379">SOCKETWRITE</a>
<tr>
<td align="left" valign="top">Socket_Writev
<td align="left" valign="top">&amp;41217
<td align="left" valign="top">socketwritev
<td align="left" valign="top"><A HREF="#10379">SOCKETWRITE</a>
</table>
</dl>

<dt>
<h5><a name="idx-5776"></a>Passing parameters</h5>
<dd>
<p>When calling a Socket_... SWI, you pass the parameters from the corresponding Socklib call in registers R0 upwards: the first parameter in R0, the second in R1, and so on.</p>
<p>Say you wish to call Socket_Accept. The equivalent call is accept:</p>
<dl>
<dd>
<p><pre>int accept(s, addr, addrlen)</pre></p>
</dl>
<p>Therefore when calling the SWI, you would pass the parameter s in R0, addr in R1, and addrlen in R2.</p>
<p>Any returned value is passed back in R0: since the accept call returns an int, this will be returned in R0 for Socket_Accept.</p>

<dt>
<h5><a name="idx-5777"></a>Errors</h5>
<dd>
<p><a name="marker-329867"></a>Errors from Socket_... SWI calls are indicated in the standard way used by RISC OS:</p>
<ul>
<li>If the V (overflow) flag is clear on return from a SWI, then no error occurred and the desired action was performed.
<li>If the V flag is set, then an error occurred, and R0 points to an error block, the first word of which contains an error number in the Internet module's reserved range of error numbers (&amp;20E00 - &amp;20EFF). The rest of the error block consists of a null-terminated error message.
</ul>
<p>The lower half of the error numbers (ie &amp;20E00 - &amp;20E7F) are used for standard Internet errors. These are &amp;20E00 greater than the corresponding Unix error number placed in the <tt>errno</tt> variable after a Socklib call. For example, EINVAL is returned from Socket_... SWI calls as &amp;20E16, but is returned from Socklib calls as &amp;16 - as defined in the C header files.</p>
<p>The upper half of the error numbers (ie &amp;20E80 - &amp;20EFF) are used for errors that are specific to DCI4 and later.</p>
<p>For a full description of how Socklib library calls deal with errors returned from Socket_... SWIs, see the description of _makecall on <A HREF="#48705">_MAKECALL</a>.<a name="marker-304772"></a></p>
</dl>

<dt>
<h2><a name="37770"></a>* Commands</h2>
<dt>
<hr><h2 align="right"><a name="12771"></a>*InetChecksum</h2>
<dd>
<dl>
<dd>
<p>Enables or disables various <a name="marker-329868"></a>protocol checksums</p>

<dt>
<h5><a name="idx-5778"></a>Syntax</h5>
<dd>
<p><tt>*InetChecksum [i|u|t On|Off]</tt></p>

<dt>
<h5><a name="idx-5779"></a>Parameters</h5>
<dd>
<p><tt>i</tt> - set IP checksum usage</p>
<p><tt>u</tt> - set UDP checksum usage</p>
<p><tt>t</tt> - set TCP checksum usage</p>
<p><tt>On</tt> - enable checksums</p>
<p><tt>Off</tt> - disable checksums</p>

<dt>
<h5><a name="idx-5780"></a>Use</h5>
<dd>
<p>*InetChecksum enables or disables various protocol checksums, or reports the current state of the checksums if you pass no parameters. You should not alter these values unless you know what you are doing.</p>

<dt>
<h5><a name="idx-5781"></a>Example</h5>
<dd>
<p><pre><b>*InetChecksum</b>
IP checksums are off, UDP checksums are off, TCP checksums are on</pre></p>
<p><pre><b>*InetChecksum u On</b></pre></p>

<dt>
<h5><a name="idx-5782"></a>Related commands</h5>
<dd>
<p>None<a name="marker-329870"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="73386"></a>*InetGateway</h2>
<dd>
<dl>
<dd>
<p>May be used to enable or to disable IP layer <a name="marker-329878"></a>packet forwarding</p>

<dt>
<h5><a name="idx-5783"></a>Syntax</h5>
<dd>
<p><tt>*InetGateway [On|Off]</tt></p>

<dt>
<h5><a name="idx-5784"></a>Parameters</h5>
<dd>
<p><tt>On</tt> - enable IP layer packet forwarding</p>
<p><tt>Off</tt> - disable IP layer packet forwarding</p>

<dt>
<h5><a name="idx-5785"></a>Use</h5>
<dd>
<p>*InetGateway may be used to enable or to disable IP layer packet forwarding (ie gateway operation) if multiple network interfaces are present. With no parameters, the current forwarding status is reported.</p>
<p>The default state is off.</p>

<dt>
<h5><a name="idx-5786"></a>Example</h5>
<dd>
<p><pre><b>*InetGateway</b>
Packet forwarding not in operation</pre></p>
<p><pre><b>*InetGateway On</b></pre></p>

<dt>
<h5><a name="idx-5787"></a>Related commands</h5>
<dd>
<p>None<a name="marker-329884"></a></p>
</dl>
<dt>
<hr><h2 align="right"><a name="37180"></a>*InetInfo</h2>
<dd>
<dl>
<dd>
<p>Displays <a name="marker-329888"></a>Internet module internal statistics</p>

<dt>
<h5><a name="idx-5788"></a>Syntax</h5>
<dd>
<p><tt>*InetInfo [r] [i] [p]</tt></p>

<dt>
<h5><a name="idx-5789"></a>Parameters</h5>
<dd>
<p><tt>r</tt> - give details of internal resource usage (the default)</p>
<p><tt>i</tt> - give details of interfaces fitted</p>
<p><tt>p</tt> - give details of protocols</p>

<dt>
<h5><a name="idx-5790"></a>Use</h5>
<dd>
<p>*InetInfo displays information and statistics about the current state of the Internet module, which forms a part of the AUN software. Most of the information displayed is runic in nature. It is presented mainly as an aid to trouble-shooting, should you require it.</p>

<dt>
<h5><a name="idx-5791"></a>Example</h5>
<dd>
<p><pre><b>*InetInfo r</b>
Resource usage:
Sockets
    Active 10
Packet forwarding not in operation</pre></p>

<dt>
<h5><a name="idx-5792"></a>Related commands</h5>
<dd>
<p>None<a name="marker-329890"></a><a name="marker-329896"></a></p>
</dl>
</dl>
</body>
</html>
